{"meta":{"title":"仓鼠杂货铺","subtitle":"Hamster","description":"sec place","author":"Hamster","url":"https://buycoffee.top","root":"/"},"pages":[{"title":"","date":"2022-10-30T05:47:07.458Z","updated":"2021-02-27T18:52:40.000Z","comments":true,"path":"mylist/index.html","permalink":"https://buycoffee.top/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-01-02T13:42:23.275Z","updated":"2021-02-27T18:49:38.000Z","comments":true,"path":"categories/index.html","permalink":"https://buycoffee.top/categories/index.html","excerpt":"","text":""},{"title":"生日快乐","date":"2022-10-31T16:00:00.000Z","updated":"2023-03-22T10:13:15.226Z","comments":true,"path":"none/Happy Birthday.html","permalink":"https://buycoffee.top/none/Happy%20Birthday.html","excerpt":"","text":"一个小小的信 178天快乐说起来好像一眨眼，就从那个湖边的小鸭子的记忆一下子就跳转到今天的可可爱爱的我们。 2022.2.14 2022.3.19 2022.5.7 2022.7.31 2022.8.27 是我，喜欢了很久的女孩呢. 2021.7.12 var ap = new APlayer({ element: document.getElementById(\"aplayer-slCYOAeD\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"LOVE\", author: \"LittleDog\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/Love.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 生日快乐，yuyu，平安喜乐，岁岁平安","author":"Hamster"},{"title":"","date":"2023-07-12T08:41:14.889Z","updated":"2023-05-18T16:50:30.820Z","comments":true,"path":"about/index.html","permalink":"https://buycoffee.top/about/index.html","excerpt":"","text":"I think music is my favorite stuff.无用幻想家文章项目GitHub 关于我关于我 你知道什么 –《关于我》 关于我建站史我是谁我是刚过2*岁生日的伪文艺青年坐标南方爱好吉他和听别人弹吉他我也对数学感到头疼但挣扎过来了Jazz爱好者不吃香菜和大葱，吃了可能会见上帝（逃 2023-05-19 换图床，修复一些bug，喝了太多咖啡☕️ 2023-03-22 修复一些bug 2022-11-01 修复一些BUG图床使用轻量应用服务器 2021-5-16 为了更易阅读与轻量化考量，换用主题Stellar 2021-03-31 使用CDN加速网站静态资源访问,提高响应速度 2021-03-05 使用vercel+coding加速网站访问 2021-03-02 完成关于页面的搭建（你现在看到的这个页面）小工具添加查看服务器状态 2021-03-01 完善菜单以及下拉栏布局添加搜索功能评论功能搭建 2021-02-28 使用Volantis主题构建页面完善页面布局完善小工具的跳转以及使用使用去不图床加快页面图片加载速度 2021-02-27 初步完成服务器以及页面的搭建使用githubpages承载，将来国内访问使用vercel加速"},{"title":"所有标签","date":"2022-10-30T05:47:07.545Z","updated":"2021-04-01T02:43:17.000Z","comments":true,"path":"tags/index.html","permalink":"https://buycoffee.top/tags/index.html","excerpt":"","text":""},{"title":"使用人脸识别开源库搭建一个消费系统","date":"2023-07-14T00:40:47.357Z","updated":"2023-05-23T09:53:22.000Z","comments":true,"path":"wiki/Face_Recognition/index.html","permalink":"https://buycoffee.top/wiki/Face_Recognition/index.html","excerpt":"","text":""},{"title":"Demo 储藏室","date":"2023-07-14T00:40:47.419Z","updated":"2023-07-03T13:50:17.000Z","comments":true,"path":"wiki/Demo Store/index.html","permalink":"https://buycoffee.top/wiki/Demo%20Store/index.html","excerpt":"","text":"关于我关于我 你知道什么 –《关于我》 这是一个Demo储藏室 2023.7.3晚上9:05瘦子-丁世光 var ap = new APlayer({ element: document.getElementById(\"aplayer-hOYGSmaE\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"瘦子\", author: \"丁世光\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/Skinney_Love.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2023.6.11晚上10:25Easy(guitar version)-Mac Ayres var ap = new APlayer({ element: document.getElementById(\"aplayer-jDmooKXC\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Easy(guitar version)\", author: \"Mac Ayres\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/easy.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2023.5.4晚上8:15表面的和平(guitar demo version)-陈绮贞 var ap = new APlayer({ element: document.getElementById(\"aplayer-eCZDgNTX\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"表面的和平(guitar demo version)\", author: \"陈绮贞\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/peace.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2022.7.26晚上10:15爱爱爱(guitar version)-方大同 var ap = new APlayer({ element: document.getElementById(\"aplayer-YSRooRLw\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"爱爱爱(guitar version)\", author: \"方大同\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/aiaiai.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2021.6.13上午3:15都好-李友廷 var ap = new APlayer({ element: document.getElementById(\"aplayer-MRaMhxHY\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"都好\", author: \"李友廷\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/613.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2021.5.30下午15:00Sometimes-Mac Ayres var ap = new APlayer({ element: document.getElementById(\"aplayer-QyqbwvID\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Sometimes\", author: \"Mac Ayres\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/47.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2021.5.15下午15:00Somebody new-Mac Ayres var ap = new APlayer({ element: document.getElementById(\"aplayer-KQrIjLVC\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Somebody new\", author: \"Mac Ayres\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/1st%20demo.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 中午13:00I’ll be your home now-Mac Ayres var ap = new APlayer({ element: document.getElementById(\"aplayer-pucBlXbj\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"I'll be your home now\", author: \"Mac Ayres\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/be%20your%20home%20now.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2021.5.15晚上23:00黑洞里-方大同 var ap = new APlayer({ element: document.getElementById(\"aplayer-wUVwbEtf\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"黑洞里\", author: \"方大同\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/black.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2021.4.26凌晨1:00nothing var ap = new APlayer({ element: document.getElementById(\"aplayer-ZgSwnIcL\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"nothing\", author: \"s\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/nothing.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2021.4.26晚上21:00en var ap = new APlayer({ element: document.getElementById(\"aplayer-vIjkIQKv\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"en?\", author: \"hamster\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/en.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2020.12.10晚上21:00难过到这边就好 var ap = new APlayer({ element: document.getElementById(\"aplayer-LFZkXOuN\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"难过到这边就好\", author: \"李友廷\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/nanguo.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2020.12.2晚上22:00麦香鱼 var ap = new APlayer({ element: document.getElementById(\"aplayer-ZLUGFzos\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"麦香鱼\", author: \"李友廷\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/fish.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2020.12.2晚上22:00宇宙小姐 var ap = new APlayer({ element: document.getElementById(\"aplayer-vnMRFyXo\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"宇宙小姐\", author: \"李友廷\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/Lady.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2020.8.11晚上22:00rnb all night var ap = new APlayer({ element: document.getElementById(\"aplayer-NeXWZXdF\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"rnb all night\", author: \"Lester\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/rnb%20all%20night.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2020.8.7凌晨3:00three o var ap = new APlayer({ element: document.getElementById(\"aplayer-NHkCZgIs\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"three o\", author: \"cangshu\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/three.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2020.8.7凌晨1:00拥抱 var ap = new APlayer({ element: document.getElementById(\"aplayer-GVBsljIH\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"拥抱\", author: \"l&h\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/hold.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2020.6.26凌晨1:00慢慢喜欢你 var ap = new APlayer({ element: document.getElementById(\"aplayer-htQkQdwo\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"慢慢喜欢你\", author: \"hamster\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/love.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2020.5.27晚上21:00love song var ap = new APlayer({ element: document.getElementById(\"aplayer-PGqDHVwn\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"love song\", author: \"hamster\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/lovesong.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2020.4.1晚上25:00说谎 var ap = new APlayer({ element: document.getElementById(\"aplayer-VfQBkToC\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"说谎\", author: \"LLX\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/lie.m4a\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"360路由器信息获取","date":"2023-05-23T09:55:46.378Z","updated":"2023-05-23T09:55:46.378Z","comments":true,"path":"wiki/Router_DATA/index.html","permalink":"https://buycoffee.top/wiki/Router_DATA/index.html","excerpt":"","text":"介绍文章: https://buycoffee.top/2023/04/29/登录获取360路由器信息%20/ GitHub项目地址: https://github.com/hamster1963/360-router-data-retriever"},{"title":"SS Server For School","date":"2023-07-14T00:40:47.400Z","updated":"2023-05-17T01:02:07.000Z","comments":true,"path":"wiki/SS Server For School/index.html","permalink":"https://buycoffee.top/wiki/SS%20Server%20For%20School/index.html","excerpt":"","text":"这是一个下载页面这是一个主要为校园网环境编写的小工具。文章程序下载GitHub源码"},{"title":"Daily CP","date":"2023-07-14T00:40:47.379Z","updated":"2023-05-17T01:07:55.000Z","comments":true,"path":"wiki/Daily CP/index.html","permalink":"https://buycoffee.top/wiki/Daily%20CP/index.html","excerpt":"","text":"这是一个下载页面这是一个主要为今日校园每日表单信息自动填写的小工具。文章程序下载(抱歉,暂不提供)"},{"title":"Python","date":"2022-10-30T05:46:09.475Z","updated":"2021-05-20T04:06:44.000Z","comments":true,"path":"wiki/categories/Python/index.html","permalink":"https://buycoffee.top/wiki/categories/Python/index.html","excerpt":"","text":""},{"title":"Demo储藏室","date":"2022-10-30T05:46:09.183Z","updated":"2021-05-17T12:56:45.000Z","comments":true,"path":"wiki/categories/Music/index.html","permalink":"https://buycoffee.top/wiki/categories/Music/index.html","excerpt":"","text":""},{"title":"Go","date":"2023-05-23T09:54:14.940Z","updated":"2023-05-23T09:54:14.940Z","comments":true,"path":"wiki/categories/Go/index.html","permalink":"https://buycoffee.top/wiki/categories/Go/index.html","excerpt":"","text":""},{"title":"应用程序","date":"2022-10-30T05:44:16.238Z","updated":"2021-05-17T12:38:47.000Z","comments":true,"path":"wiki/categories/App/index.html","permalink":"https://buycoffee.top/wiki/categories/App/index.html","excerpt":"","text":""}],"posts":[{"title":"搭配GitHub Actions为Release增加Changelog","slug":"搭配GitHub Actions为Release增加Changelog 2b9af1cd39284deb8dcae3d3720abf46","date":"2023-07-15T16:00:00.000Z","updated":"2023-07-16T04:56:46.228Z","comments":true,"path":"2023/07/16/搭配GitHub Actions为Release增加Changelog 2b9af1cd39284deb8dcae3d3720abf46/","link":"","permalink":"https://buycoffee.top/2023/07/16/%E6%90%AD%E9%85%8DGitHub%20Actions%E4%B8%BARelease%E5%A2%9E%E5%8A%A0Changelog%202b9af1cd39284deb8dcae3d3720abf46/","excerpt":"","text":"前言在浏览GitHub上许多知名的社区项目时，总能在Release中看到各种不同的Changelog，其中通常包含这代码的提交信息，有一些则是重大的更新点，其中有人工进行Changelog编写的，也有许多是使用自动化工具生成的。 Goframe项目的Changelog 于是我们尝试在Speed-Cron项目中引入自动化的Changelog生成工具，帮助我们生成好看又实用的Changelog。 最终效果 目前常见的Changelog自动化工具目前社区中有十分多不同风格与用法的Changelog自动化生成工具，比如npm中的 auto-changelog ，或者GitHub官方的Automatically generated release notes，而今天选用的，则是一款在GitHub上知名度较高的 git-cliff ，git-cliff 是用rust语言编写的自动化生产变更日志的工具，可以通过下载二进制文件在本地生成 Changelog ，或者引入到GitHub Actions中进行使用。 在本项目中，我们将利用git-cliff官方的Actions套件为Release阶段生成Changelog。 配置方式https://git-cliff.org/docs/github-actions/git-cliff-action 在官方的文档中对于如何在Actions中使用git-cliff有很详细的介绍。通过在workflow文件中引入并配置git-cliff Actions即可。 - name: Check out repository uses: actions/checkout@v3 with: fetch-depth: 0- name: Generate a changelog uses: orhun/git-cliff-action@v2 with: config: cliff.toml args: --verbose env: OUTPUT: CHANGELOG.md 可以使用默认的cliff.toml，或者我们自定义更符合我们需求的git-cliff配置文件。 在项目中，我们创建一个git-cliff文件夹以用来存放git-cliff的配置文件，现在直接先摆上完整的配置文件。 # git-cliff ~ configuration file# https://git-cliff.org/docs/configuration## Lines starting with &quot;#&quot; are comments.# Configuration options are organized into tables and keys.# See documentation for more information on available options.[changelog]# changelog headerheader = &quot;&quot;&quot;# Changelog\\n&quot;&quot;&quot;# template for the changelog body# https://tera.netlify.app/docs/body = &quot;&quot;&quot;&#123;% if version %&#125;\\ ## Release &#123;&#123; version | trim_start_matches(pat=&quot;v&quot;) &#125;&#125; - &#123;&#123; timestamp | date(format=&quot;%Y-%m-%d&quot;) &#125;&#125;&#123;% else %&#125;\\ ## [unreleased]&#123;% endif %&#125;\\&#123;% for group, commits in commits | group_by(attribute=&quot;group&quot;) %&#125; ### &#123;&#123; group | upper_first &#125;&#125; &#123;% for commit in commits %&#125; - &#123;&#123; commit.message | upper_first &#125;&#125; ([&#123;&#123; commit.id | truncate(length=7, end=&quot;&quot;) &#125;&#125;](https://github.com/hamster1963/Speed-Cron/commit/&#123;&#123; commit.id &#125;&#125;))\\ &#123;% for footer in commit.footers -%&#125; , &#123;&#123; footer.token &#125;&#125;&#123;&#123; footer.separator &#125;&#125;&#123;&#123; footer.value &#125;&#125;\\ &#123;% endfor %&#125;\\ &#123;% endfor %&#125;&#123;% endfor %&#125;\\n&quot;&quot;&quot;# remove the leading and trailing whitespace from the templatetrim = true# changelog footerfooter = &quot;&quot;&quot;&quot;&quot;&quot;[git]# parse the commits based on https://www.conventionalcommits.orgconventional_commits = true# filter out the commits that are not conventionalfilter_unconventional = true# process each line of a commit as an individual commitsplit_commits = true# regex for preprocessing the commit messagescommit_preprocessors = [ &#123; pattern = &#x27;\\((\\w+\\s)?#([0-9]+)\\)&#x27;, replace = &quot;([#$&#123;2&#125;](https://github.com/orhun/git-cliff/issues/$&#123;2&#125;))&quot; &#125;,]# regex for parsing and grouping commitscommit_parsers = [ &#123; message = &quot;^feat&quot;, group = &quot;&lt;!-- 0 --&gt;⛰️ Features&quot; &#125;, &#123; message = &quot;^fix&quot;, group = &quot;&lt;!-- 1 --&gt;🐛 Bug Fixes&quot; &#125;, &#123; message = &quot;^doc&quot;, group = &quot;&lt;!-- 3 --&gt;📚 Documentation&quot; &#125;, &#123; message = &quot;^perf&quot;, group = &quot;&lt;!-- 4 --&gt;⚡ Performance&quot; &#125;, &#123; message = &quot;^refactor&quot;, group = &quot;&lt;!-- 2 --&gt;🚜 Refactor&quot; &#125;, &#123; message = &quot;^style&quot;, group = &quot;&lt;!-- 5 --&gt;🎨 Styling&quot; &#125;, &#123; message = &quot;^test&quot;, group = &quot;&lt;!-- 6 --&gt;🧪 Testing&quot; &#125;, &#123; message = &quot;^chore\\\\(release\\\\): prepare for&quot;, skip = true &#125;, &#123; message = &quot;^chore\\\\(pr\\\\)&quot;, skip = true &#125;, &#123; message = &quot;^chore\\\\(pull\\\\)&quot;, skip = true &#125;, &#123; message = &quot;^chore&quot;, group = &quot;&lt;!-- 7 --&gt;⚙️ Miscellaneous Tasks&quot; &#125;, &#123; body = &quot;.*security&quot;, group = &quot;&lt;!-- 8 --&gt;🛡️ Security&quot; &#125;,]# protect breaking changes from being skipped due to matching a skipping commit_parserprotect_breaking_commits = false# filter out the commits that are not matched by commit parsersfilter_commits = false# glob pattern for matching git tagstag_pattern = &quot;v[0-9]*&quot;# regex for skipping tagsskip_tags = &quot;&quot;# regex for ignoring tagsignore_tags = &quot;v.*-beta.*&quot;# sort the tags topologicallytopo_order = false# sort the commits inside sections by oldest/newest ordersort_commits = &quot;oldest&quot; 可以在配置文件中看出，主要的配置块分为Changelog部分与GitHub部分，分别对Changelog的格式以及读取GitHub的行为进行配置。 在Changelog部分，我们将每一行的commit都看做一个独立的变更（虽然在多人项目中不太建议）。 # process each line of a commit as an individual commitsplit_commits = true 并且在变更的末尾附上对应的commit_id，方便直接在Changelog页面可以直接点击跳转到对应的commit变更对比页面中。 在变更类别中，分为: commit_parsers = [ &#123; message = &quot;^feat&quot;, group = &quot;&lt;!-- 0 --&gt;⛰️ Features&quot; &#125;, &#123; message = &quot;^fix&quot;, group = &quot;&lt;!-- 1 --&gt;🐛 Bug Fixes&quot; &#125;, &#123; message = &quot;^doc&quot;, group = &quot;&lt;!-- 3 --&gt;📚 Documentation&quot; &#125;, &#123; message = &quot;^perf&quot;, group = &quot;&lt;!-- 4 --&gt;⚡ Performance&quot; &#125;, &#123; message = &quot;^refactor&quot;, group = &quot;&lt;!-- 2 --&gt;🚜 Refactor&quot; &#125;, &#123; message = &quot;^style&quot;, group = &quot;&lt;!-- 5 --&gt;🎨 Styling&quot; &#125;, &#123; message = &quot;^test&quot;, group = &quot;&lt;!-- 6 --&gt;🧪 Testing&quot; &#125;, &#123; message = &quot;^chore\\\\(release\\\\): prepare for&quot;, skip = true &#125;, &#123; message = &quot;^chore\\\\(pr\\\\)&quot;, skip = true &#125;, &#123; message = &quot;^chore\\\\(pull\\\\)&quot;, skip = true &#125;, &#123; message = &quot;^chore&quot;, group = &quot;&lt;!-- 7 --&gt;⚙️ Miscellaneous Tasks&quot; &#125;, &#123; body = &quot;.*security&quot;, group = &quot;&lt;!-- 8 --&gt;🛡️ Security&quot; &#125;,] 那么多类，通过正则表达式进行匹配分类到不同的类别中。 对于版本号的格式：正式分发的版本采用v.0.0.1的格式进行,如为测试版则是v0.0.1-beta.1的版本格式。因此需要在tag_pattern与ignore-tags中定义区分正式版与测试版本的正则表达式。 # glob pattern for matching git tagstag_pattern = &quot;v[0-9]*&quot;# regex for ignoring tagsignore_tags = &quot;v.*-beta.*&quot; 这样定义之后，正式版进行生成变更日志时会寻找上一条正式版的版本记录，会跳过与测试版本的比对，这样子就可以将测试过程中的变更日志也一并包含到最后的正式版中。 目前为止基础的配置就完成了。 配置GitHub Actions我们在jobs中定义一个job专门用以生成Changelog文本并显示在对应的Release变更日志中。 在配置文件中，将路径改为仓库中存放git-cliff配置文件的路径。 在Release step中，将生成的Changelog文本推送至对应的变更日志中。 完整Release workflow如下: name: build-go-binaryon: release: types: [created] # 表示在创建新的 Release 时触发jobs: changelog: name: Generate changelog runs-on: ubuntu-latest outputs: release_body: $&#123;&#123; steps.git-cliff.outputs.content &#125;&#125; steps: - name: Checkout uses: actions/checkout@v3 with: fetch-depth: 0 - name: Generate a changelog uses: orhun/git-cliff-action@v2 id: git-cliff with: config: git-cliff/cliff.toml args: -vv --latest --strip &#x27;footer&#x27; env: OUTPUT: CHANGES.md - name: Release uses: softprops/action-gh-release@v1 if: startsWith(github.ref, &#x27;refs/tags/&#x27;) with: body: $&#123;&#123; steps.git-cliff.outputs.content &#125;&#125; token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; env: GITHUB_REPOSITORY: $&#123;&#123; github.repository &#125;&#125; build-go-binary: ... 注意事项在workflow中，我们使用到$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;作为身份验证，需要在设置中开启对于仓库的读写权限，请参考上篇文章中的配置步骤。 最后好看的Release Changelog也是吸引更多用户的一个有效手段，同时对于后续的维护人员，也可以简单地通过Changelog快速了解到不同版本号之间的差异。Hope u enjoy!","categories":[{"name":"GitHub","slug":"GitHub","permalink":"https://buycoffee.top/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://buycoffee.top/tags/GitHub/"}],"author":"Hamster"},{"title":"多Docker仓库Github Actions流程","slug":"多Docker仓库Github Actions流程 d5807c069f7742fd9fe5d9081ca00f0b","date":"2023-07-12T16:00:00.000Z","updated":"2023-07-13T14:59:48.491Z","comments":true,"path":"2023/07/13/多Docker仓库Github Actions流程 d5807c069f7742fd9fe5d9081ca00f0b/","link":"","permalink":"https://buycoffee.top/2023/07/13/%E5%A4%9ADocker%E4%BB%93%E5%BA%93Github%20Actions%E6%B5%81%E7%A8%8B%20d5807c069f7742fd9fe5d9081ca00f0b/","excerpt":"","text":"实现目的公司后端的服务采用Docker镜像的方式进行分发与部署，之前选用DockerHub作为托管平台，但由于DockerHub对于私有仓库数的限制以及最近各种网络状况频出，选用GitHub在2020年推出的ghcr以及阿里云的容器镜像服务都可以更好的满足公司内部对于安全以及持续集成的需求。 GitHub Actions整个CICD的流程都采用GitHub Actions来进行，采用GitHub Actions的优点有很多，不仅可以很方便的看到整个自动化的进度，而且从维护成本来看只需要管理好GitHub Actions的配置文件即可，配置文件也叫做工作流文件(workflow)，采用yml格式文件进行编写。 推送至ghcr与阿里云在Actions中，我们采用几个核心的步骤来进行镜像的打包，标记与分发。 首先进行不同库的登录操作，目的是获取对应仓库的操作权限。 对镜像进行不同仓库的对应标记，使其可以上传到对应的仓库中。 进行分发。 在GitHub Actions中有许多已经封装好核心逻辑的Action可供使用，有官方的也有第三方的，在本Action中与Docker相关的操作都采用了docker官方出品的Action。 登录操作由于ghcr是GitHub官方的镜像库，因此用户名与密码并不需要显式定义出来，用户名用$&#123;&#123; github.repository_owner &#125;&#125; ,password用$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;即可，需要注意的是，上传至ghcr需要开放github_token对于库的读写权限，可在仓库设置中开启。 在Settings-Actions-General中，将Workflow permissions的权限勾选为读写权限。 对于阿里云的镜像管理服务，则需要在secret中定义从阿里云获取的用户名与密码。 - name: Login to GitHub Container Registry uses: docker/login-action@v2 with: registry: ghcr.io username: $&#123;&#123; github.repository_owner &#125;&#125; password: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;- name: Login to AliYun Container Registry uses: docker/login-action@v2 with: registry: registry.cn-guangzhou.aliyuncs.com username: $&#123;&#123; secrets.ALI_USERNAME &#125;&#125; password: $&#123;&#123; secrets.ALI_TOKEN &#125;&#125; 对镜像进行标记在images一栏中填入ghcr与阿里云的镜像地址即可，下方的tags为标记的逻辑。 默认采用latest与当前tag版本号即可。 - name: Extract metadata (tags, labels) for Docker id: meta uses: docker/metadata-action@v4 with: images: | ghcr.io/$&#123;&#123; github.repository &#125;&#125; registry.cn-guangzhou.aliyuncs.com/hamster-home/kes-speed-backend tags: | type=raw,value=latest type=ref,event=tag 进行镜像的推送- name: Build and push Docker image uses: docker/build-push-action@v4 with: context: . push: true tags: $&#123;&#123; steps.meta.outputs.tags &#125;&#125; labels: $&#123;&#123; steps.meta.outputs.labels &#125;&#125; 推送后续推送后即可在GitHub以及阿里云中看到最新推送的镜像。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://buycoffee.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://buycoffee.top/tags/Docker/"},{"name":"GitHub","slug":"GitHub","permalink":"https://buycoffee.top/tags/GitHub/"}],"author":"Hamster"},{"title":"用Go构建一套网络监控系统","slug":"网络监控 683f1c2b3b3d4a30bef2a2e52259eef2","date":"2023-07-01T16:00:00.000Z","updated":"2023-07-03T01:46:40.244Z","comments":true,"path":"2023/07/02/网络监控 683f1c2b3b3d4a30bef2a2e52259eef2/","link":"","permalink":"https://buycoffee.top/2023/07/02/%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7%20683f1c2b3b3d4a30bef2a2e52259eef2/","excerpt":"","text":"项目背景入职第二天，主管就马上下来了一个需求，监控终端的网络。原因是公司的网络很差，总是有同事反映网络很慢，钉钉不断断开重连，连接本地的群晖文件服务器也有问题，但目前的同事的应对手段主要就是重启路由器与服务器，总是没有从根源上解决问题，因此想找到一个可以稳定监控的方法。 网络架构公司主营业务是跨境电商，因此在宽带的数量上达到了惊人的6条宽带，其中4条为专线宽带，不需要太多操心，其他例如运营，设计，开发与IT部门共用2条宽带，分别是电信的500M与联通的1000M宽带，从网络设备上来看就比较有意思了。 联通光猫→蒲公英路由 电信光猫→蒲公英路由 采用了链路聚合的形式，将两条宽带结合为一条宽带进行使用，蒲公英后台设置中为双wan模式，由蒲公英对数据包的分发进行管理。 而在AP方面，都采用了钉钉的C1路由器作为AP进行使用，接入钉钉的智能办公网络，在新人入职后可以很方便的直接在钉钉中点击智能办公室网络小程序进行网络的连接，进行打卡或是访问内网。 从架构来看，主要就是在蒲公英端或者是在钉钉AP端出现了某些问题，需要对网络继续一个基本的测试后再进行问题的排查。 项目构想想要持续监控终端网络的状况，主要还是得看到达员工端电脑上的网络速率，很多时候自己拿着去测觉得网络状态不错，但实际使用中由于不同电脑的各种硬件不同也可能会产生许多问题。 马上第一个想法便是利用speedtest的功能，定时在终端上进行测速，再通过某个渠道将数据进行汇总，这样便可以很方便的看到不同设备中的速度了，也很容易看到问题的大概方向。因此花了一个整体架构的草图，非常的简单，便是在终端，例如手提或者台式机器上利用speedtest进行测速，再构建一个后端系统进行数据的汇总，架构就完成了。 项目选型简单的架构完成后，马上遇到的问题就是，如何利用speedtest以及用什么语言去构建安装在终端上的定时测速程序呢？ 首先第一个问题很快得到了解决，Ookla公司旗下的Speedtest工具为开发者提供了Speedtest CLI，这意味着我只需要去调用CLI并且获得数据即可完成测速的功能。简单了解指令后便设置用json格式获取测速CLI的输出以获得测速的数据。 完整的命令为: cmd := exec.Command(&quot;speed_cli/speedCLI/speedtest.exe&quot;, &quot;--accept-gdpr&quot;, &quot;--accept-license&quot;, &quot;56634&quot;, &quot;--progress=yes&quot;, &quot;--format=json&quot;, &quot;--progress-update-interval=200&quot;) 其中，”–accept-gdpr”与”–accept-license”可以跳过初次启动CLI需要输入YES同意的条款提示， “56634”则是指定的测速服务器id，可以使得结果比较具有统一性，后续主要为获取数据的配置，–format=json将CLI的输出配置为JSON格式，可以很好的用map的形式去管理测速数据。 在语言选择方面，首先这门语言必须占用资源少，不会影响到终端的正常工作，其次语言应该具有良好的多架构适配性以可以安装在公司不同架构的电脑上，比如arm，amd64等，最后是最好可以编译为二进制文件，便于适配系统后台服务以及工具的分发。 没错，在考虑了开发需求与开发成本中，结果很明显，使用Golang语言进行客户端测速程序的编写明显是一个很好的选择。同时在框架上，选用了后端的goframe框架进行魔改后可以方便的利用到框架内的例如缓存，HTTP客户端以及定时任务的功能，降低了很多的开发成本。 核心的问题解决了，那就进行开发吧。 客户端开发到了开发更多就是根据语言特性选择不同的模块去实现功能了。这里主要介绍定时任务这个功能。 定时任务直接采用goframe框架中的gcron-定时任务进行构建。gcron模块提供了对定时任务的实现，支持类似crontab的配置管理方式，并支持最小粒度到秒的定时任务管理。 使用起来非常的简单，只需要在客户端程序启动的时候，进行定时任务的注册即可。 func addSpeedCron(ctx context.Context, initData g.Map, timePattern string) (err error) &#123; glog.Notice(ctx, &quot;开始定时测速服务&quot;, timePattern) _, err = gcron.AddSingleton(ctx, timePattern, func(ctx context.Context) &#123; err := cli_utils.CmdCore.StartSpeedCmd(ctx, initData) if err != nil &#123; glog.Error(ctx, &quot;定时测速服务失败: &quot;, err) return &#125; &#125;, &quot;Speed-Cron&quot;) if err != nil &#123; glog.Warning(ctx, &quot;添加定时测速服务失败: &quot;, err) return err &#125; return&#125; timePattern选择gcorn库中的预定义格式，默认为@every 1h 同时定时任务选择为单例模式，避免上次的测速未结束又进行了第二次测速造成测速CLI的冲突。 在goframe项目启动中，定时任务便也启动，按照定义好的时间间隔进行测速命令的执行。 为了后端对于客户端有足够的控制权限，timePattern内容与测速节点id是从后端进行获取的，这便需要客户端定时向后端获取最新的客户端配置，并且根据配置的内容再进行测速定时任务的创建。 glog.Debug(ctx, &quot;开始初始化定时任务管理器&quot;) _, err = gcron.AddSingleton(ctx, &quot;@every 30s&quot;, func(ctx context.Context) &#123; err := cron_utils.CronManage.GetConfigAndStart(ctx, initData) if err != nil &#123; glog.Error(ctx, &quot;初始化定时任务管理器服务失败: &quot;, err) return &#125; &#125;, &quot;Cron-Manager&quot;) if err != nil &#123; glog.Warning(ctx, &quot;添加初始化定时任务管理器服务失败: &quot;, err) return err &#125; 采用配置定时任务管理器的形式进行测速定时任务的管理。 // 获取测速定时任务 localSpeedCron := gcron.Search(&quot;Speed-Cron&quot;) if localSpeedCron == nil &#123; glog.Notice(ctx, &quot;本地不存在定时任务,添加Speed-Cron定时任务&quot;) err = addSpeedCron(ctx, initData, speedInterval) if err != nil &#123; glog.Warning(ctx, &quot;添加Speed-Cron定时器失败&quot;) return &#125; &#125; else &#123; speedEntryPattern := reflect.ValueOf(localSpeedCron).Elem().FieldByName(&quot;schedule&quot;).Elem().FieldByName(&quot;pattern&quot;) if speedEntryPattern.String() != speedInterval &#123; glog.Notice(ctx, &quot;更新Speed-Cron定时器&quot;) // 更新定时任务 gcron.Stop(&quot;Speed-Cron&quot;) gcron.Remove(&quot;Speed-Cron&quot;) err = addSpeedCron(ctx, initData, speedInterval) if err != nil &#123; glog.Warning(ctx, &quot;更新Speed-Cron定时器失败&quot;) return &#125; return &#125; else &#123; glog.Notice(ctx, &quot;Speed-Cron定时器无需更新&quot;) &#125; &#125; 在获取配置后，将本地的配置与服务器的配置进行比对，如果有改变，则找到原本的测速定时任务进行销毁再根据新配置创建新的定时任务。在这里比较特别的是，在gcron中，定时任务在创建完成后，其中时间间隔字段是私有字段，不能从外部直接获取，因此这里采用反射对测速定时任务的结构体进行了私有字段的获取以用以与服务器配置进行比对。 最后比较核心的模块便是与Speedtest CLI的交互了，十分的简单，这里直接给出完整的命令行信息获取函数。 // StartSpeedCmd//// @dc: 开始测速命令行交互// @params:// @response:// @author: hamster @date:2023/6/20 10:06:06func (u *uCmdCore) StartSpeedCmd(ctx context.Context, initData g.Map) (err error) &#123; cmd := CliUtils.CreateSpeedCmd() if cmd == nil &#123; glog.Warning(ctx, &quot;创建命令失败,获取测速节点失败&quot;) err = gerror.New(&quot;创建命令失败,获取测速节点失败&quot;) return &#125; // 获取命令的标准输出管道 stdout, err := cmd.StdoutPipe() if err != nil &#123; glog.Warning(ctx, &quot;获取标准输出管道时发生错误:&quot;, err) return &#125; // 启动命令 err = cmd.Start() if err != nil &#123; glog.Warning(ctx, &quot;启动命令时发生错误:&quot;, err) return &#125; var ( scanner = bufio.NewScanner(stdout) defaultBars = Bar.InitDefaultBar() uploadNetDataStruct = &amp;NetInfoUploadData&#123;&#125; ) uploadNetDataStruct.Department = gconv.String(initData[&quot;department&quot;]) uploadNetDataStruct.StaffName = gconv.String(initData[&quot;name&quot;]) // 持续获取输出 for scanner.Scan() &#123; // 获取输出行 line := scanner.Bytes() ok, err := CmdProgress.CmdCoreProgress(ctx, string(line), defaultBars, uploadNetDataStruct) if err != nil &#123; glog.Warning(ctx, &quot;处理命令行输出时发生错误:&quot;, err) return err &#125; if ok &#123; return nil &#125; &#125; // 等待命令执行完成 err = cmd.Wait() if err != nil &#123; glog.Warning(ctx, &quot;等待命令执行完成时发生错误:&quot;, err) &#125; return&#125; 核心就是创建了一个命令行的输出管道，通过for scanner.Scan() 的方式不断获取命令行的输出再进行处理。 测速完成后，组装信息上传至后端即可。 系统服务在终端上进行，那就需要服务可以一直在后台运行，最好具有错误重启，开机自启动的功能，在对比了nvvm与winsw后，选用winsw进行Windows端系统服务的构建。 配置十分简单，配置一些基础的信息，搭配github上的预编译文件加命令即可完成系统服务的注册与开启。 &lt;service&gt; &lt;id&gt;v0.1.0&lt;/id&gt; &lt;name&gt;My Go Application&lt;/name&gt; &lt;description&gt;This is a Windows service for running my Go application.&lt;/description&gt; &lt;executable&gt;%BASE%\\core_bin\\speed_cron.exe&lt;/executable&gt; &lt;workingdirectory&gt;%BASE%\\core_bin&lt;/workingdirectory&gt; &lt;arguments&gt;-department=IT -name=方大同&lt;/arguments&gt; &lt;logpath&gt;%BASE%\\logs&lt;/logpath&gt; &lt;logmode&gt;roll&lt;/logmode&gt; &lt;onfailure action=&quot;restart&quot; delay=&quot;10 sec&quot;&gt;&lt;/onfailure&gt;&lt;/service&gt; 定义完成后利用install与start便可以将定时测速客户端注册为服务运行在系统后台 后端构建增删查改，建好数据库的表就可以了，再添加一个定时检测机器状态的定时任务即可。 监控一段时间后发现的问题在部分网络状态不佳的设备上安装并等待一段数据的上报后，首先发现，怎么网段都不一样… 在清一色的10网段中，怎么混入了172网段？！ 艰辛万苦的排查后，发现是某台钉钉的路由器错误地设置为了路由模式，造成DHCP直接变成又钉钉路由器进行，就造成了网段的不一样，而由于钉钉路由器在路由模式下性能很差…就造成了连到这台路由器的设备会出现网络卡顿，断线的情况。 第一个问题解决了，还剩下一个就是网络总是定期有波动，从测速数据来看波动还是挺大的，最后从外部ip中发现了问题，发现蒲公英切换到电信500M的时候网络状态就十分不理想，解决办法很简单，把蒲公英路由器上电信那条网线拔了，对你没有听错…. 问题都解决了。 一些后话解决完这个问题后总感觉为了一碟醋包了一盘饺子…但是转念一想，没有这些大量数据的支撑，也很难通过测试发现问题的所在，同时在过程中也发现有一些是网卡硬件或者网线的问题造成协商速率只有100M，这些通过人工去测试当然也行，但是程序员就是懒嘛！让同事小手一点安装一下，等个半天看看数据再去处理，也是非常的轻松惬意，同时系统还可以接入比如预警，消息通知的第三方以完成更高程度监控自动化，也是非常灵活的！（嘴硬） 最后谢谢你看到这里，希望其中的一些golang實作可以给你一些启发。","categories":[{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/tags/Go/"},{"name":"Network","slug":"Network","permalink":"https://buycoffee.top/tags/Network/"}],"author":"Hamster"},{"title":"利用watchtower实现Docker容器的自动更新部署","slug":"利用watchtower实现Docker容器的自动更新部署","date":"2023-05-23T16:00:00.000Z","updated":"2023-05-23T13:09:30.000Z","comments":true,"path":"2023/05/24/利用watchtower实现Docker容器的自动更新部署/","link":"","permalink":"https://buycoffee.top/2023/05/24/%E5%88%A9%E7%94%A8watchtower%E5%AE%9E%E7%8E%B0Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E9%83%A8%E7%BD%B2/","excerpt":"","text":"在前几篇文章中，讨论了利用Github Actions针对Go项目进行构建与打包镜像，而本文章关注于在简单场景下，单体应用的自动检测镜像版本并在获取到新版本时自动更新并清除旧版本的镜像，这对于测试环境或个人开发者来说较为方便，也可以减少手动更新所带来的时间成本。 实现效果 在Github打包上传镜像至DockerHub后，部署服务的服务器通过watchtower进行检测更新并拉取镜像进行替换更新。完成后进行消息推送的通知。 watchtower项目地址: https://github.com/containrrr/watchtower Watchtower配置文件在所需部署的服务器上采用docker-compose启动watchtower服务，指定版本为1.5.3，在不指定的情况下，latest可能并不能拉取到最新版本的镜像。在WATCHTOWER_NOTIFICATION_URL 中，需要指明的是如果不是通过slack，discord等途径进行消息推送，而是通过http webhook的形式进行推送，则需要在URL前加上generic表明采用原生请求进行推送。 version: &quot;3&quot;services: watchtower: image: containrrr/watchtower:1.5.3 volumes: - /var/run/docker.sock:/var/run/docker.sock command: --interval 15 --cleanup nasnetwork_push_go-push-go-1 push_go_docker-push-go-1 environment: WATCHTOWER_NOTIFICATION_REPORT: &quot;true&quot; WATCHTOWER_NOTIFICATION_TITLE_TAG: &quot;hamster&quot; WATCHTOWER_NOTIFICATION_URL: &quot;generic+http://yourip:port/DockerUpdatePushCore&quot; WATCHTOWER_NOTIFICATION_DELAY: 5 WATCHTOWER_NOTIFICATION_TEMPLATE: | &#123;&#123;- if .Report -&#125;&#125; &#123;&#123;- with .Report -&#125;&#125; &#123;&#123;len .Scanned&#125;&#125; Scanned, &#123;&#123;len .Updated&#125;&#125; Updated, &#123;&#123;len .Failed&#125;&#125; Failed &#123;&#123;- range .Updated&#125;&#125; - &#123;&#123;.Name&#125;&#125; (&#123;&#123;.ImageName&#125;&#125;): &#123;&#123;.CurrentImageID.ShortID&#125;&#125; updated to &#123;&#123;.LatestImageID.ShortID&#125;&#125; &#123;&#123;- end -&#125;&#125; &#123;&#123;- range .Fresh&#125;&#125; - &#123;&#123;.Name&#125;&#125; (&#123;&#123;.ImageName&#125;&#125;): &#123;&#123;.State&#125;&#125; &#123;&#123;- end -&#125;&#125; &#123;&#123;- range .Skipped&#125;&#125; - &#123;&#123;.Name&#125;&#125; (&#123;&#123;.ImageName&#125;&#125;): &#123;&#123;.State&#125;&#125;: &#123;&#123;.Error&#125;&#125; &#123;&#123;- end -&#125;&#125; &#123;&#123;- range .Failed&#125;&#125; - &#123;&#123;.Name&#125;&#125; (&#123;&#123;.ImageName&#125;&#125;): &#123;&#123;.State&#125;&#125;: &#123;&#123;.Error&#125;&#125; &#123;&#123;- end -&#125;&#125; &#123;&#123;- end -&#125;&#125; &#123;&#123;- else -&#125;&#125; &#123;&#123;range .Entries -&#125;&#125;&#123;&#123;.Message&#125;&#125;&#123;&#123;&quot;\\n&quot;&#125;&#125;&#123;&#123;- end -&#125;&#125; &#123;&#123;- end -&#125;&#125; 如不需要推送服务，则无需添加environment部分内容。 version: &quot;3&quot;services: watchtower: image: containrrr/watchtower:1.5.3 volumes: - /var/run/docker.sock:/var/run/docker.sock command: --interval 15 --cleanup nasnetwork_push_go-push-go-1 push_go_docker-push-go-1 volumes指定系统下docker.sock的路径，而在command中进行绑定需要监测的容器与其他命令，在上述command中， —interval 指定每次检测的间隔秒数，15则为15秒 —cleanup 指定在更新容器后清理旧容器与旧镜像 nasnetwork_push_go-push-go-1 与 push_go_docker-push-go-1 都为容器名，可通过docker ps 进行查看，多个容器之间通过空格进行分割。 部署首先通过 docker-compose pull 进行镜像的拉取 拉取完成后，通过docker-compose up -d 进行watchtower的启动 完成后即可通过查看日志获取检测结果信息。 总结通过这几篇文章，可以以较小的维护成本与开发成本构建一套属于自己的CI/CD流程，利用Docker容器轻松进行容器的分发与部署。后续会继续介绍统一消息推送中心以及k8s与k3s的构建与部署。 之前的文章： https://buycoffee.top/2023/05/01/使用GitHub Actions为Go项目实现简易CI:CD/ https://buycoffee.top/2023/05/23/利用Github Actions为Go程序添加git与编译信息/","categories":[{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/categories/Go/"},{"name":"Docker","slug":"Go/Docker","permalink":"https://buycoffee.top/categories/Go/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://buycoffee.top/tags/Docker/"},{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/tags/Go/"}],"author":"Hamster"},{"title":"利用Github Actions为Go程序添加git与编译信息","slug":"利用Github Actions为Go程序添加git与编译信息","date":"2023-05-23T09:40:00.000Z","updated":"2023-05-23T09:43:33.000Z","comments":true,"path":"2023/05/23/利用Github Actions为Go程序添加git与编译信息/","link":"","permalink":"https://buycoffee.top/2023/05/23/%E5%88%A9%E7%94%A8Github%20Actions%E4%B8%BAGo%E7%A8%8B%E5%BA%8F%E6%B7%BB%E5%8A%A0git%E4%B8%8E%E7%BC%96%E8%AF%91%E4%BF%A1%E6%81%AF/","excerpt":"","text":"实现效果可以通过/version获取到当前服务的git版本号以及相关信息，也可以看到编译时间与编译环境等信息。 实现原理在进行Go程序的编译时，可以通过传入额外的参数来修改编译过程，比较常见的有： o &lt;output&gt;: 指定输出文件的名称。例如，go build -o myprogram将生成名为 myprogram 的可执行文件。 ldflags &quot;&lt;flags&gt;&quot;: 用于传递链接器（ld）的标志。您可以使用此选项将特定标志传递给链接器，例如设置版本信息或自定义链接行为。例如，go build -ldflags &quot;-X main.version=1.0.0&quot;将在构建过程中设置名为 version 的变量的值为 1.0.0。 gcflags &quot;&lt;flags&gt;&quot;: 用于传递Go编译器（gc）的标志。您可以使用此选项传递特定标志给编译器，例如优化级别或其他调试信息。例如，go build -gcflags &quot;-N -l&quot; 将禁用优化并生成带有调试信息的可执行文件。 本次的实现则是利用ldflags &quot;&lt;flags&gt;&quot;指令进行信息的注入。 核心构建指令go build -o ./temp/release/linux_amd64/service -ldflags &quot; -X &#x27;home-network-watcher/utility/bin_utils.GitTag=v1.11.12&#x27; -X &#x27;home-network-watcher/utility/bin_utils.GitCommitLog=8405a9a7a15c33399d8cc400f08836e14b9dc085&#x27; -X &#x27;home-network-watcher/utility/bin_utils.BuildTime=2023.05.21.03:56:22&#x27; -X &#x27;home-network-watcher/utility/bin_utils.BuildGoVersion=github@action golang:1.20-buster&#x27; &quot; main.go 接下来进行Go代码与GitHub Actions、Dockerfile的编写。 Go美化注入代码新建一个.Go文件，以变量的形式用以储存在程序中需要的git与版本信息，并创建一个函数用以美化显示信息。 创建需要注入信息的变量，设置默认值为unknown，等待编译注入再进行重新赋值。 package binInfoimport ( &quot;fmt&quot; &quot;runtime&quot; &quot;strings&quot;)// 初始化为 unknown，如果编译时没有传入这些值，则为 unknownvar ( GitTag = &quot;unknown&quot; GitCommitLog = &quot;unknown&quot; GitStatus = &quot;unknown&quot; BuildTime = &quot;unknown&quot; BuildGoVersion = &quot;unknown&quot;)var ( VersionString = &quot;GitTag:&quot; + GitTag + &quot;\\n&quot; + &quot;GitCommitLog:&quot; + GitCommitLog + &quot;\\n&quot; + &quot;GitStatus:&quot; + GitStatus + &quot;\\n&quot; + &quot;BuildTime:&quot; + BuildTime + &quot;\\n&quot; + &quot;BuildGoVersion:&quot; + BuildGoVersion + &quot;\\n&quot;)/*// StringifySingleLine 返回单行格式func StringifySingleLine() string &#123; return fmt.Sprintf(&quot;GitTag=%s. GitCommitLog=%s. GitStatus=%s. BuildTime=%s. GoVersion=%s. runtime=%s/%s.&quot;, GitTag, GitCommitLog, GitStatus, BuildTime, BuildGoVersion, runtime.GOOS, runtime.GOARCH)&#125;*/// StringifyMultiLine 返回多行格式func StringifyMultiLine() string &#123; return fmt.Sprintf(&quot;GitTag=%s\\nGitCommitLog=%s\\nGitStatus=%s\\nBuildTime=%s\\nGoVersion=%s\\nruntime=%s/%s\\n&quot;, GitTag, GitCommitLog, GitStatus, BuildTime, BuildGoVersion, runtime.GOOS, runtime.GOARCH)&#125;func init() &#123; beauty()&#125;// 对一些值做美化处理func beauty() &#123; if GitStatus == &quot;&quot; &#123; // GitStatus 为空时，说明本地源码与最近的 commit 记录一致，无修改 // 为它赋一个特殊值 GitStatus = &quot;cleanly&quot; &#125; else &#123; // 将多行结果合并为一行 GitStatus = strings.Replace(strings.Replace(GitStatus, &quot;\\r\\n&quot;, &quot; |&quot;, -1), &quot;\\n&quot;, &quot; |&quot;, -1) &#125;&#125; 在Go项目中显示git与编译信息可在main.go中设置命令行参数进行信息显示。 如下代码，在运行编译后的二进制文件时，通过-v进行信息显示。 package mainimport ( &quot;flag&quot; &quot;fmt&quot; _ &quot;github.com/gogf/gf/contrib/drivers/mysql/v2&quot; &quot;github.com/gogf/gf/v2/os/gctx&quot; &quot;home-network-watcher/internal/cmd&quot; _ &quot;home-network-watcher/internal/logic&quot; _ &quot;home-network-watcher/internal/packed&quot; binInfo &quot;home-network-watcher/utility/bin_utils&quot; &quot;os&quot;)func main() &#123; v := flag.Bool(&quot;v&quot;, false, &quot;Show bin info.&quot;) flag.Parse() if *v &#123; _, _ = fmt.Fprint(os.Stderr, binInfo.StringifyMultiLine()) os.Exit(1) &#125; cmd.Main.Run(gctx.New())&#125; 或者可以通过绑定接口的形式，在访问服务/version 时进行信息的显示。 group.ALL(&quot;/version&quot;, func(r *ghttp.Request) &#123; r.Response.Write(binInfo.VersionString)&#125;) Dockerfile编写首先定义Go构建器 FROM golang:1.20-buster AS builder 设置需要注入的构建参数的默认值 ARG GIT_TAG=&quot;unknown&quot;ARG GIT_COMMIT_LOG=&quot;unknown&quot;ARG BUILD_TIME=&quot;unknown&quot;ARG BUILD_GO_VERSION=&quot;github@action golang:1.20-buster&quot; 关键的注入则是通过在docker进行构建时也可以进行参数的绑定这个特性来完成的。 GitHub Action将ARG的参数传入docker build后，接下来则将信息传入到gf build或者go build中，首先构建传入的信息。 # 设置 LDFlags 变量ENV LDFLAGS=&quot; \\ -X &#x27;home-network-watcher/utility/bin_utils.GitTag=$&#123;GIT_TAG&#125;&#x27; \\ -X &#x27;home-network-watcher/utility/bin_utils.GitCommitLog=$&#123;GIT_COMMIT_LOG&#125;&#x27; \\ -X &#x27;home-network-watcher/utility/bin_utils.BuildTime=$&#123;BUILD_TIME&#125;&#x27; \\ -X &#x27;home-network-watcher/utility/bin_utils.BuildGoVersion=$&#123;BUILD_GO_VERSION&#125;&#x27; \\&quot; 以&#39;home-network-watcher/utility/bin_utils.GitTag=$&#123;GIT_TAG&#125;&#39; 为例 go通过追溯包名进行参数数据的传递，在上述定义存储变量的Go文件中，模块为&quot;home-network-watcher/utility/bin_utils” ，则在构建时也是传入包名加内部的变量名进行数据传递，在这里我们将上面获取到的GIT_TAG传递给GitTag变量。 最后则是通过go build传递进去 RUN go build -ldflags &quot;$&#123;LDFLAGS&#125;&quot; -o temp/release/linux_amd64/service main.go 以下为完整Dockerfile FROM golang:1.20-buster AS builder# 设置构建参数的默认值ARG GIT_TAG=&quot;unknown&quot;ARG GIT_COMMIT_LOG=&quot;unknown&quot;ARG BUILD_TIME=&quot;unknown&quot;ARG BUILD_GO_VERSION=&quot;github@action golang:1.20-buster&quot;WORKDIR /go/src/appCOPY . .# 打印构建参数RUN echo &quot;GIT_TAG=$&#123;GIT_TAG&#125;&quot;RUN echo &quot;GIT_COMMIT_LOG=$&#123;GIT_COMMIT_LOG&#125;&quot;RUN echo &quot;BUILD_TIME=$&#123;BUILD_TIME&#125;&quot;RUN echo &quot;BUILD_GO_VERSION=$&#123;BUILD_GO_VERSION&#125;&quot;# 设置 LDFlags 变量ENV LDFLAGS=&quot; \\ -X &#x27;home-network-watcher/utility/bin_utils.GitTag=$&#123;GIT_TAG&#125;&#x27; \\ -X &#x27;home-network-watcher/utility/bin_utils.GitCommitLog=$&#123;GIT_COMMIT_LOG&#125;&#x27; \\ -X &#x27;home-network-watcher/utility/bin_utils.BuildTime=$&#123;BUILD_TIME&#125;&#x27; \\ -X &#x27;home-network-watcher/utility/bin_utils.BuildGoVersion=$&#123;BUILD_GO_VERSION&#125;&#x27; \\&quot;RUN go get github.com/gogf/gf/cmd/gf/v2RUN go install github.com/gogf/gf/cmd/gf/v2RUN gf build -e &quot;-ldflags \\&quot;$&#123;LDFLAGS&#125;\\&quot; &quot;# RUN go build -ldflags &quot;$&#123;LDFLAGS&#125;&quot; -o temp/release/linux_amd64/service main.goFROM loads/alpine:3.8LABEL maintainer=&quot;Hamster &lt;liaolaixin@gmail.com&gt;&quot;################################################################################ INSTALLATION################################################################################ 设置固定的项目路径ENV WORKDIR /app/mainCOPY --from=builder /go/src/app/temp/release/linux_amd64/service $WORKDIR/service# 添加应用可执行文件，并设置执行权限RUN chmod +x $WORKDIR/service# 增加端口绑定EXPOSE 10401################################################################################ START###############################################################################WORKDIR $WORKDIRCMD [&quot;./service&quot;] Github Actions编写十分简单，只需要利用Actions里面可以方便获取的git信息即可，通过—build-arg传递入docker build中 name: Build and push Docker imageon: push: tags: - &#x27;v*&#x27;env: IMAGE_NAME: $&#123;&#123; secrets.DOCKER_IMAGE_NAME &#125;&#125;jobs: build-and-push: runs-on: ubuntu-latest steps: - name: Get version id: get_version run: echo &quot;CURRENT_VERSION=$&#123;GITHUB_REF/refs\\/tags\\//&#125;&quot; &gt;&gt; $GITHUB_ENV - name: Get Git Commit Log id: git-commit-log run: echo &quot;GIT_COMMIT_LOG=$&#123;&#123; github.sha &#125;&#125;&quot; &gt;&gt; $GITHUB_ENV - name: Get Build Time id: build-time run: echo &quot;BUILD_TIME=$(date +&#x27;%Y.%m.%d.%H:%M:%S&#x27;)&quot; &gt;&gt; $GITHUB_ENV - name: Checkout code uses: actions/checkout@v3 - name: Login to Dockerhub uses: docker/login-action@v2 with: username: $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125; password: $&#123;&#123; secrets.DOCKER_ACCESS_TOKEN &#125;&#125; - name: Build Docker image run: docker build -t $IMAGE_NAME:$&#123;&#123; github.sha &#125;&#125; . --build-arg GIT_TAG=$&#123;&#123;env.CURRENT_VERSION&#125;&#125; --build-arg GIT_COMMIT_LOG=&quot;$&#123;&#123;env.GIT_COMMIT_LOG&#125;&#125;&quot; --build-arg BUILD_TIME=$&#123;&#123;env.BUILD_TIME&#125;&#125; - name: Print environment variables run: | echo &quot;$&#123;&#123;env.GIT_COMMIT_LOG&#125;&#125;&quot; echo &quot;$&#123;&#123;env.BUILD_TIME&#125;&#125;&quot; echo &quot;$&#123;&#123;env.CURRENT_VERSION&#125;&#125;&quot; - name: Tag Docker image run: docker tag $IMAGE_NAME:$&#123;&#123; github.sha &#125;&#125; $IMAGE_NAME:$&#123;&#123; env.CURRENT_VERSION &#125;&#125; - name: Tag Docker image as latest run: docker tag $IMAGE_NAME:$&#123;&#123; github.sha &#125;&#125; $IMAGE_NAME:latest - name: Push Docker image run: | docker push $IMAGE_NAME:$&#123;&#123; env.CURRENT_VERSION &#125;&#125; docker push $IMAGE_NAME:latest 将获取到的信息首先储存在$GITHUB_ENV中，在构建docker build指令时进行传递 docker build -t $IMAGE_NAME:$&#123;&#123; github.sha &#125;&#125; . --build-arg GIT_TAG=$&#123;&#123;env.CURRENT_VERSION&#125;&#125; --build-arg GIT_COMMIT_LOG=&quot;$&#123;&#123;env.GIT_COMMIT_LOG&#125;&#125;&quot; --build-arg BUILD_TIME=$&#123;&#123;env.BUILD_TIME&#125;&#125; 这样子便完成了git与版本信息的注入，十分的自动便捷。 结语主要的难点还是如何将信息在整个构建的过程中传递下去，只要可以传递好所需的信息在构建的时候即可以方便地通过go build的-ldflags将信息传递入二进制文件中。","categories":[{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/categories/Go/"},{"name":"Docker","slug":"Go/Docker","permalink":"https://buycoffee.top/categories/Go/Docker/"},{"name":"Github","slug":"Go/Docker/Github","permalink":"https://buycoffee.top/categories/Go/Docker/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://buycoffee.top/tags/Github/"},{"name":"Docker","slug":"Docker","permalink":"https://buycoffee.top/tags/Docker/"},{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/tags/Go/"}],"author":"Hamster"},{"title":"使用GitHub Actions为Go项目实现简易CI/CD","slug":"使用GitHub Actions为Go项目实现简易CI:CD","date":"2023-04-30T16:00:00.000Z","updated":"2023-05-01T07:52:38.000Z","comments":true,"path":"2023/05/01/使用GitHub Actions为Go项目实现简易CI:CD/","link":"","permalink":"https://buycoffee.top/2023/05/01/%E4%BD%BF%E7%94%A8GitHub%20Actions%E4%B8%BAGo%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93CI:CD/","excerpt":"","text":"Github Actions与CI/CDGitHub Actions是GitHub提供的一种自动化工具，可以帮助您在代码仓库中自动执行任务，如构建、测试和部署。CI/CD（持续集成/持续部署）是一种自动化软件开发实践，可以帮助您更快地交付高质量的软件。在本文中，我们将介绍如何使用GitHub Actions为Go项目实现简易CI/CD。 实现目标 将Actions主要分为三个部分 在代码提交后进行编译检查，检查是否存在代码错误。 在进行git tag操作后，针对tag进行docker镜像的构建与推送。 达到版本号发布时，自动构建多平台可执行二进制文件。 前置准备为Actions开放仓库权限在仓库主页，选中Settings→Actions→General→Workflow permissions，将权限设置为Read and write permisssions。 获取Docker相关信息将信息储存在Actions secrets and variables中，分别设置Docker用户名，token与仓库名称。 获取 Docker token 的步骤如下： 登录到 Docker Hub 帐户。 点击右上角的头像，选择“Account Settings”。 在左侧菜单中选择“Security”。 滚动到“Access Tokens”部分，然后单击“New Access Token”按钮。 输入访问令牌的描述，选择令牌的有效期，并选择要授予令牌的权限。 单击“Create”按钮以生成令牌。 复制生成的令牌并保存在安全的地方。 仓库名称则为 用户名/仓库名 进行secrets的设置在Settings→Secrets and variables中点击New repository secret进行新增。 DOCKER_USERNAME DOCKER_ACCESS_TOKEN DOCKER_IMAGE_NAME 设置Actions点击仓库内Actions模块，点击New workflow进行工作流的新增。 代码编译检查工作流将会在检测到push或pull_request后进行代码编译检查。 # This workflow will build a golang project# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-goname: 代码编译测试on: push: branches: [ &quot;main&quot; ] pull_request: branches: [ &quot;main&quot; ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Go uses: actions/setup-go@v3 with: go-version: 1.19 - name: Build run: | go build -v ./... pwd 编译构建并推送Docker镜像此工作流只会在仓库新增tag时进行。 git tag v0.0.1git push --tags 工作流分为以下几个步骤 获取tag作为版本号 根据Dockerfile进行Docker镜像的构建 针对构建完成镜像进行tag打版本号 将镜像推送至Dockerhub name: Build and push Docker imageon: push: tags: - &#x27;v*&#x27;env: IMAGE_NAME: $&#123;&#123; secrets.DOCKER_IMAGE_NAME &#125;&#125;jobs: build-and-push: runs-on: ubuntu-latest steps: - name: Get version id: get_version run: echo &quot;VERSION=$&#123;GITHUB_REF/refs\\/tags\\//&#125;&quot; &gt;&gt; $GITHUB_OUTPUT - name: Checkout code uses: actions/checkout@v3 - name: Login to Dockerhub uses: docker/login-action@v2 with: username: $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125; password: $&#123;&#123; secrets.DOCKER_ACCESS_TOKEN &#125;&#125; - name: Build Docker image run: docker build -t $IMAGE_NAME:$&#123;&#123; github.sha &#125;&#125; . - name: Tag Docker image run: docker tag $IMAGE_NAME:$&#123;&#123; github.sha &#125;&#125; $IMAGE_NAME:$&#123;&#123; steps.get_version.outputs.VERSION &#125;&#125; - name: Tag Docker image as latest run: docker tag $IMAGE_NAME:$&#123;&#123; github.sha &#125;&#125; $IMAGE_NAME:latest - name: Push Docker image run: | docker push $IMAGE_NAME:$&#123;&#123; steps.get_version.outputs.VERSION &#125;&#125; docker push $IMAGE_NAME:latest 这时我们需要针对项目进行Dockerfile的编写，一下是一个针对Goframe项目的示例。 设置golang构建环境，有许多版本可以选择，可以参考https://hub.docker.com/_/golang，这里选择golang:1.20-buster。 拷贝代码至构建环境，进行构建，在这里将编译完成后将二进制文件命名为service，构建命令也可以指定系统与架构，在命令中加上GOOS=linux GOARCH=amd64。 设置镜像环境，设置工作路径，为二进制文件添加权限并增加端口绑定。 设置入口命令。 至此一份Dockerfile就编写完成了。 FROM golang:1.20-buster AS builderARG VERSION=devWORKDIR /go/src/appCOPY . .RUN CGO_ENABLED=0 go build -o service -ldflags=-X=main.version=$&#123;VERSION&#125; main.goFROM loads/alpine:3.8LABEL maintainer=&quot;Hamster &lt;liaolaixin@gmail.com&gt;&quot;################################################################################ INSTALLATION################################################################################ 设置固定的项目路径ENV WORKDIR /app/mainCOPY --from=builder /go/src/app/service $WORKDIR/service# 添加应用可执行文件，并设置执行权限RUN chmod +x $WORKDIR/service# 增加端口绑定EXPOSE 10399################################################################################ START###############################################################################WORKDIR $WORKDIRCMD [&quot;./service&quot;] 新增后通过git tag测试工作流，检查Dockerhub是否有最新构建镜像。 编译多平台二进制文件设置为只在新增release时进行构建，可以设置需要的系统架构或排除的，十分简单易用。 name: build-go-binaryon: release: types: [created] # 表示在创建新的 Release 时触发jobs: build-go-binary: runs-on: ubuntu-latest strategy: matrix: goos: [linux, windows, darwin] # 需要打包的系统 goarch: [amd64, arm64] # 需要打包的架构 exclude: # 排除某些平台和架构 - goarch: arm64 goos: windows steps: - uses: actions/checkout@v3 - uses: wangyoucao577/go-release-action@v1 with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; # 一个默认的变量，用来实现往 Release 中添加文件 goos: $&#123;&#123; matrix.goos &#125;&#125; goarch: $&#123;&#123; matrix.goarch &#125;&#125; goversion: 1.18 # 可以指定编译使用的 Golang 版本 binary_name: &quot;push_go&quot; # 可以指定二进制文件的名称 pre_command: export CGO_ENABLED=0 &amp;&amp; export GODEBUG=http2client=0 overwrite: true 在仓库中新增release并测试，等待编译完成后即可在release中查看不同系统架构的二进制文件。 消息通知可针对Actions的进度进行消息通知，在Settings→Webhooks设置推送目标URL，搭配自建的消息推送即可实现在手机上获取Actions进度流程。 TODO: 可复用工作流","categories":[{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/categories/Go/"},{"name":"Docker","slug":"Go/Docker","permalink":"https://buycoffee.top/categories/Go/Docker/"},{"name":"Github","slug":"Go/Docker/Github","permalink":"https://buycoffee.top/categories/Go/Docker/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://buycoffee.top/tags/Github/"},{"name":"Docker","slug":"Docker","permalink":"https://buycoffee.top/tags/Docker/"},{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/tags/Go/"}],"author":"Hamster"},{"title":"逆向破解登录获取360路由器信息","slug":"登录获取360路由器信息 ","date":"2023-04-28T16:00:00.000Z","updated":"2023-04-29T10:12:19.371Z","comments":true,"path":"2023/04/29/登录获取360路由器信息 /","link":"","permalink":"https://buycoffee.top/2023/04/29/%E7%99%BB%E5%BD%95%E8%8E%B7%E5%8F%96360%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BF%A1%E6%81%AF%20/","excerpt":"","text":"项目介绍360路由器目前没有无损刷机的办法，获取ssh终端权限较为困难，如想获取路由器状态信息以及连接设备信息就比较困难，但可以通过采用逆向破解网页登陆的形式进行后台的登录进行信息获取。 项目地址https://github.com/hamster1963/360-router-data-retriever 实现效果采用代码进行360后台的登录，进行路由器信息的获取。 登陆过程分析抓包直接采用Safari的开发者工具进行抓包。 在输入框中输入管理员密码进行登录。 可以看到页面首先请求了get_rand_key.cgi（CGI是通用网关接口，是一种比较传统的动态网页的实现方式），通过Get方法获取到了一串随机的字符串。 在获取完成后进行一些暂时未知的处理后请求了web_login.cgi，请求数据中包括了管理员用户名与密码，可以发现pass密码中的值并不是我们所填入的密码值，首先猜测可能为md5或aes加密后的字符串。 查看登陆接口在登陆成功后的返还与Header。接口返还了登陆状态码以及Token-ID字段数据，同时在返回的Header中可以看到有Set-Cookie字段，猜测在后续的数据接口中应该会在请求头中携带token以及cookie进行权限验证。 查看后续请求头，可以观察到在Cookie中携带了先前返回的信息，包含Set-Cookie以及token信息。 目前为止，可以对登陆过程进行一个小总结。 输入账号密码→点击登录→获取随机字符串→进行加密→请求登录接口→获取Cookie以及token 目前主要难点为如何进行加密的逆向破解。 逆向首先尝试md5加密，与目标密码不一致。 其次尝试简单粗暴的方式，查源码。查看js代码后，发现js代码进过webpack混淆打包，从函数名以及变量名中很难找出加密的代码块，因此使用关键词进行搜索。 果然还是简单粗暴比较有用，在搜索到AES关键词后，可以从代码中发现密码加密的关键逻辑 for (;;) switch (t.prev = t.next) &#123; case 0: return t.next = 2, c(0).then((function(t) &#123; r = n || t; var o = a.enc.Hex.parse(r.rand_key), u = a.enc.Latin1.parse(&quot;360luyou@install&quot;), c = a.AES.encrypt(e, o, &#123; iv: u, mode: a.mode.CBC, padding: a.pad.Pkcs7 &#125;); i = c.ciphertext.toString() &#125;)); case 2: return t.abrupt(&quot;return&quot;, r.key_index + i); case 3: case &quot;end&quot;: return t.stop() &#125; for (;;) switch (t.prev = t.next) &#123; case 0: if (r = e.substr(32, e.length - 32), i = &#123;&#125;, !n) &#123; t.next = 6; break &#125; i.rand_key = n, t.next = 9; break; case 6: return t.next = 8, c(0, e, !0); case 8: i = t.sent; case 9: if (i.rand_key) &#123; t.next = 11; break &#125; return t.abrupt(&quot;return&quot;, e); case 11: return u = a.enc.Hex.parse(i.rand_key), s = a.enc.Latin1.parse(&quot;360luyou@install&quot;), d = a.enc.Hex.parse(r).toString(a.enc.Base64), p = a.AES.decrypt(d, u, &#123; iv: s, mode: a.mode.CBC, padding: a.pad.Pkcs7 &#125;), t.abrupt(&quot;return&quot;, p.toString(a.enc.Utf8)); case 16: case &quot;end&quot;: return t.stop() &#125; 虽然变量名与函数名被混淆，但可以从代码中看到采用AES加密。 首先进行加密前的处理，对rand_key进行hex，定义iv，设置模式为CBC，padding为PKCS7。 加密步骤为： 获取rand_key的后32位进行hex 对密码进行PKCS7Encode 最后以hex后的rand_key作为key，PKCS7Encode后的密码作为plainText，360luyou@install字符串进行hex后作为iv 进行AES加密 在加密结束后，将前rand_key前32位与加密字符串进行拼接作为pass传输到路由器进行登录验证。 代码实现这里给出Python与Go的加密示例。 def gen_aes_str(rand_key: bytes): mode = AES.MODE_CBC iv = b&#x27;\\x33\\x36\\x30\\x6c\\x75\\x79\\x6f\\x75\\x40\\x69\\x6e\\x73\\x74\\x61\\x6c\\x6c&#x27; # &quot;360luyou@install&quot;.decode(&#x27;hex&#x27;) encryptor = AES.new(rand_key, mode, iv) encoder = PKCS7Encoder() text = &quot;password&quot; # password pad_text = encoder.encode(text) cipher = encryptor.encrypt(bytes(pad_text, &quot;utf-8&quot;)) return cipher // GenerateAesString 生成加密字符串func (r *Router) GenerateAesString() (err error) &#123; // 判断随机字符串是否为空 if r.randStr == &quot;&quot; &#123; g.Dump(&quot;randStr is empty&quot;) err := r.GetRandomString() if err != nil &#123; g.Dump(err) return err &#125; &#125; // randKey := &quot;fbf8a1ca3b31ace17adece7f6941a278017ff28b58200c5a153e07f5dc840b3f&quot; decodeString, err := hex.DecodeString(r.randStr[32:]) if err != nil &#123; g.Dump(err) return &#125; block, err := aes.NewCipher(decodeString) if err != nil &#123; panic(err) &#125; encryptor := cipher.NewCBCEncrypter(block, configs.DefaultAesIv) p7 := utils.PKCS7Encoder&#123;BlockSize: 16&#125; padded := p7.Encode([]byte(r.Password)) cipherText := make([]byte, len(padded)) encryptor.CryptBlocks(cipherText, padded) r.aesStr = hex.EncodeToString(cipherText) if r.aesStr == &quot;&quot; &#123; g.Dump(&quot;aesStr is empty&quot;) return errors.New(&quot;aesStr is empty&quot;) &#125; g.Dump(gtime.Now().String() + &quot; Generate AESKey &quot; + r.aesStr) return&#125; Go项目代码层级完整的登陆以及获取信息由Go代码进行编写。 首先定义不同模块的接口以及结构体 type LoginMethod interface &#123; Login() error&#125;type AesMethod interface &#123; GetRandomString() error GenerateAesString() error&#125;type Router struct &#123; Address string Password string state bool aesIv []byte inHeaders map[string]string randStr string aesStr string token string cookie string Headers map[string]string&#125; type RouterMethod interface &#123; GetRouterInfo() error&#125; 最后以嵌套接口的形式将不同模块组合起来。 type RouterController interface &#123; LoginMethod AesMethod RouterMethod&#125; 在调用时，采用接口赋值的形式调用接口内的方法，使程序变得更加灵活且便于维护。 func main() &#123; var routerMain internal.RouterController myRouter := internal.Router&#123; Address: configs.RouterAddress, Password: configs.RouterPassword, &#125; routerMain = &amp;myRouter err := routerMain.GetRandomString() if err != nil &#123; g.Dump(err) return &#125; err = routerMain.GenerateAesString() if err != nil &#123; g.Dump(err) return &#125; err = routerMain.Login() if err != nil &#123; g.Dump(err) return &#125; err = routerMain.GetRouterInfo() if err != nil &#123; g.Dump(err) return &#125;&#125;","categories":[{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/tags/Go/"},{"name":"Router","slug":"Router","permalink":"https://buycoffee.top/tags/Router/"}],"author":"Hamster"},{"title":"Go语言项目内存泄露问题的发现与解决","slug":"一次Go语言内存泄露问题的发现与解决","date":"2023-04-23T16:00:00.000Z","updated":"2023-05-01T07:22:36.000Z","comments":true,"path":"2023/04/24/一次Go语言内存泄露问题的发现与解决/","link":"","permalink":"https://buycoffee.top/2023/04/24/%E4%B8%80%E6%AC%A1Go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%A7%A3%E5%86%B3/","excerpt":"","text":"问题描述后端功能为采集家庭网络信息并对外开放接口，每1s或每5s进行采集。 采用docker打包Go编译完成后的二进制文件，通过docker-compose部署在云服务器上。 在运行一段时间后，内存报警，内存占用不断增高，怀疑发生了内存泄漏，且GC在其中无法清理内存。 原功能实现原功能采用for关键词加time.Sleep进行实现，参考于Python服务器探针代码。 while True: CPU = get_cpu() Uptime = get_uptime() Load_1, Load_5, Load_15 = os.getloadavg() MemoryTotal, MemoryUsed, SwapTotal, SwapFree = get_memory() HDDTotal, HDDUsed = get_hdd() get_router_info() 在Go代码中，为获取一段时间内的消耗流量与消耗流量最多用户，创建了两个变量。 var maxFLow intvar maxFLowUser string 并在后续的计算中给变量赋值 // 计算用户流量变化 for _, user := range userList.Array() &#123; userMap := gconv.Map(user) for _, userNow := range userListNow &#123; userNowMap := gconv.Map(userNow) if userMap[&quot;id&quot;] == userNowMap[&quot;id&quot;] &#123; // 计算用户流量变化 totalFlow := gconv.Int(userNowMap[&quot;down&quot;]) - gconv.Int(userMap[&quot;down&quot;]) if totalFlow &gt; maxFLow &#123; maxFLow = totalFlow maxFLowUser = gconv.String(userNowMap[&quot;remark&quot;]) &#125; &#125; &#125; &#125; 内存泄露原因由于采用for关键词，在 Go 中，如果在 for 循环中创建了一个新的变量，但在每个循环迭代中没有将其重新分配，则可能会导致内存泄漏。 例如，以下代码段将创建一个新的字符串，并在每个循环迭代中将其连接到另一个字符串上，但它没有在每个迭代中将新字符串重新分配： var result stringfor i := 0; i &lt; 1000000; i++ &#123; newString := &quot;hello&quot; result += newString&#125; 在这种情况下，每次迭代都会创建一个新的字符串，但由于新的字符串没有重新分配，因此在每个迭代后，将有一个新的字符串和一个旧的字符串（在 result 变量中）仍然引用它。这会导致大量的内存泄漏，因为旧的字符串仍然存在于内存中，而无法被垃圾回收器清理。 为了避免内存泄漏，可以在每个迭代中将新字符串重新分配给变量，如下所示： var result stringfor i := 0; i &lt; 1000000; i++ &#123; newString := &quot;hello&quot; result += newString newString = &quot;&quot; // 重新分配&#125; 通过将新字符串分配给一个新变量，可以确保每次迭代都有一个新的变量来引用新的字符串，从而避免内存泄漏。在重新分配新变量后，旧的字符串将不再被引用，并且可以被垃圾回收器清理。 归根结底，则是在每次循环中创建的变量一直处在引用状态，GC无法正确对其进行垃圾回收，导致程序内存占用一直在不断升高。 解决办法采用Go语言的思路进行书写，项目基于Goframe框架，重构后采用框架中的gcron（定时任务）进行定期的数据拉取，函数内部定义参数可在函数在执行结束后结束引用关系，避免采用for循环造成内存泄露。 _, err = gcron.AddSingleton(ctx, &quot;*/5 * * * * *&quot;, func(ctx context.Context) &#123; err = network_utils.NodeUtils.GetNodeInfo() if err != nil &#123; g.Dump(err) &#125; &#125;, &quot;获取当前代理节点信息&quot;) if err != nil &#123; panic(err) &#125; 关于GCGo语言的垃圾回收（GC）是在运行时进行的，不是在函数结束后。Go语言的垃圾回收器是一种并发、自适应的垃圾回收器，它会在程序运行时自动检测内存使用情况，并在必要时回收不再使用的内存。 具体来说，Go语言的垃圾回收器会在程序运行时周期性地扫描堆内存中的对象，标记那些仍然被引用的对象，然后清理那些未被引用的对象。垃圾回收器的执行时间由当前程序的内存使用情况和硬件配置等因素决定，并不一定在函数结束后立即进行。 总之，Go语言的垃圾回收是一种自动的、并发的机制，它可以在程序运行时周期性地回收未被引用的内存。这种机制可以减少程序员的内存管理负担，提高程序的可靠性和性能。","categories":[{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/categories/Go/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://buycoffee.top/tags/Docker/"},{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/tags/Go/"}],"author":"Hamster"},{"title":"家庭负载均衡节点部署","slug":"实现负载均衡节点分享 ","date":"2023-04-14T16:00:00.000Z","updated":"2023-04-15T07:36:47.215Z","comments":true,"path":"2023/04/15/实现负载均衡节点分享 /","link":"","permalink":"https://buycoffee.top/2023/04/15/%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%8A%82%E7%82%B9%E5%88%86%E4%BA%AB%20/","excerpt":"","text":"实现原因身边的几个朋友有着查查谷歌学术，逛逛ig的需求，但是都对科学上网了解不多且对软件的认知还停在vpn阶段。 因此计划利用家用服务器进行节点的搭建，对外只暴露为vmess节点，内部为多个机场与服务器组成的负载均衡节点，在保障科学上网稳定的同时也可以降低朋友们的学习成本，采用流行的软件进行连接即可。 最终效果外部节点效果 x-ui面板管理节点界面 v2rayA界面 Uptime Kuma节点监控界面 Bark推送示例 架构设计架构为下图所示 在路由器针对单用户节点进行端口转发，在xui中设置出站流量转发至v2raya。 部署环境在nas上进行部署，配置如下图，配置不高但转发性能远大于家宽上传带宽，因此将就一下也可以。 全部组件都在Docker上进行部署，便于后续的维护与升级。 v2raya搭建项目地址 https://github.com/v2rayA/v2rayA 本次项目的核心负载均衡部分由开源项目v2rayA进行控制，v2rayA 是一个支持全局透明代理的 V2Ray Linux 客户端，同时兼容SS、SSR、Trojan(trojan-go)、PingTunnel协议。 采用Docker进行部署v2rayA采用Docker进行部署。在本项目中由于我们主要将v2rayA用以对外服务，因此在部署时不采用host模式，手动进行端口的开放。我们只需要开发管理后台的2017端口以及接收x-ui面板转发socks5流量的20172端口（可自行选择更换）。也可以开放更多端口供后续其他用途。 # run v2rayadocker run -d \\ -p 2017:2017 \\ -p 20170-20172:20170-20172 \\ --restart=always \\ --name v2raya \\ -e V2RAYA_LOG_FILE=/tmp/v2raya.log \\ -v /etc/v2raya:/etc/v2raya \\ mzz2017/v2raya 管理后台配置因为v2rayA的用途为节点的负载均衡，因此在设置中可以将分流关闭，对外只作为一个节点，并且将透明代理与系统代理关闭，不进行过多的流量处理。 在设置中开启端口分享，在地址与端口中将socks5端口绑定到Docker部署时开放的端口。 节点的添加与负载均衡v2rayA可以添加服务器与订阅多种使用节点的方式，点击创建为新建单节点，点击导入则为订阅。 在添加完节点与订阅后，只需点击节点后的选择，即为加入负载均衡列表中。 负载均衡的原理为针对每个节点进行延迟的测试，自动连接延迟最低的节点进行使用。在PROXY中可以配置延迟测试的站点，测试间隔时间。 配置完成后，点击左上角运行按钮，等待显示正在运行蓝色按钮即配置完成。也可在左边栏中查看当前节点连接情况与延迟。 x-ui搭建x-ui为一个支持多协议多用户的xray面板，在项目中只要用作对外开放节点的管理以及将出口流量转发至v2rayA。 采用Docker进行部署x-ui在部署x-ui时，采用host模式进行部署，避免后续节点新增带来的端口映射问题。 mkdir x-ui &amp;&amp; cd x-uidocker run -itd --network=host \\ -v $PWD/db/:/etc/x-ui/ \\ -v $PWD/cert/:/root/cert/ \\ --name x-ui --restart=unless-stopped \\ enwaiax/x-ui:latest 部署完成后，访问ip:54321进行面板的访问，初始用户名与密码为admin。 登陆完成后，务必修改用户名与密码。 x-ui流量转发配置此步将配置x-ui全部的出站流量转发至v2rayA中，达到采用负载均衡节点的目的。 在面板设置中的xray项目相关设置中进行设置。 &#123; &quot;api&quot;:&#123; &quot;services&quot;:[ &quot;HandlerService&quot;, &quot;LoggerService&quot;, &quot;StatsService&quot; ], &quot;tag&quot;:&quot;api&quot; &#125;, &quot;inbounds&quot;:[ &#123; &quot;listen&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:62789, &quot;protocol&quot;:&quot;dokodemo-door&quot;, &quot;settings&quot;:&#123; &quot;address&quot;:&quot;127.0.0.1&quot; &#125;, &quot;tag&quot;:&quot;api&quot; &#125; ], &quot;outbounds&quot;:[ &#123; &quot;protocol&quot;:&quot;socks&quot;, &quot;settings&quot;:&#123; &quot;servers&quot;:[ &#123; &quot;address&quot;:&quot;192.168.31.93&quot;, &quot;port&quot;:20172, &quot;users&quot;:[ ] &#125; ] &#125; &#125;, &#123; &quot;protocol&quot;:&quot;freedom&quot;, &quot;tag&quot;:&quot;direct&quot;, &quot;settings&quot;:&#123; &#125; &#125;, &#123; &quot;protocol&quot;:&quot;blackhole&quot;, &quot;settings&quot;:&#123; &#125;, &quot;tag&quot;:&quot;blocked&quot; &#125; ], &quot;policy&quot;:&#123; &quot;system&quot;:&#123; &quot;statsInboundDownlink&quot;:true, &quot;statsInboundUplink&quot;:true &#125; &#125;, &quot;routing&quot;:&#123; &quot;rules&quot;:[ &#123; &quot;inboundTag&quot;:[ &quot;api&quot; ], &quot;outboundTag&quot;:&quot;api&quot;, &quot;type&quot;:&quot;field&quot; &#125;, &#123; &quot;ip&quot;:[ &quot;geoip:private&quot; ], &quot;outboundTag&quot;:&quot;blocked&quot;, &quot;type&quot;:&quot;field&quot; &#125;, &#123; &quot;type&quot;:&quot;field&quot;, &quot;domain&quot;:[ &quot;geosite:cn&quot; ], &quot;outboundTag&quot;:&quot;direct&quot; &#125;, &#123; &quot;type&quot;:&quot;field&quot;, &quot;ip&quot;:[ &quot;geoip:cn&quot; ], &quot;outboundTag&quot;:&quot;direct&quot; &#125;, &#123; &quot;outboundTag&quot;:&quot;blocked&quot;, &quot;protocol&quot;:[ &quot;bittorrent&quot; ], &quot;type&quot;:&quot;field&quot; &#125; ] &#125;, &quot;stats&quot;:&#123; &#125;&#125; 核心在outbounds中，进行协议的配置与目标服务器ip与端口的配置，此处填入服务器内网ip与socks5端口即可。 添加节点进行测试在入站列表进行对外节点的添加，选择vmess协议，端口随机生成，其余配置不变点击添加。 可以利用软件扫描节点二维码进行连接测试。 DDNS在上述组件配置完成后，最后一步则是进行域名的配置，因为家宽的ip通常在72小时会进行重新拨号获取，因此采用DDNS用于动态域名解析，省去手动更换ip进行连接的使用成本。 本项目采用DDNS-Go进行动态解析。在Domains中填入需要动态解析的域名即可。IP变更通知配置可采用bark推送进行通知。 路由器进行端口转发并通过域名进行节点连接在路由器后台针对单节点进行端口转发即可用域名加端口的方式进行节点连接。 节点监控采用uptimekuma进行节点的监控，采用bark进行推送。 在xui新建一个加密的sock5节点（注意⚠️：这种方式并不安全），记录信息后在uptimekuma中进行创建新监控服务。 通过检测访问https://gstatic.com/generate_204进行节点连通性的检测。 节点通知采用bark进行节点状态的通知，关于推送配置可直接使用Uptime Kuma中的bark配置或BarkPush-Go进行多设备统一推送，此项目仍在完善中，请关注后续文章。 服务器监控最后可以针对nas整体进行状态的监控，本项目采用哪吒探针进行监控。 https://github.com/naiba/nezha 最后的话生命不息，折腾不止。 如有任何疑问与建议务必留言，每条留言都会用心回复。","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://buycoffee.top/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://buycoffee.top/tags/Docker/"},{"name":"网络","slug":"网络","permalink":"https://buycoffee.top/tags/%E7%BD%91%E7%BB%9C/"}],"author":"Hamster"},{"title":"关于音乐的分享","slug":"音乐分享","date":"2021-05-20T04:13:42.000Z","updated":"2023-05-17T01:13:59.340Z","comments":true,"path":"2021/05/20/音乐分享/","link":"","permalink":"https://buycoffee.top/2021/05/20/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/","excerpt":"","text":"前言 Hello大家好!!! 这是我第一次尝试写下关于音乐分享的文章，很不成熟也很可能味如嚼蜡，谢谢您的谅解！！ 推荐歌单仅仅是个人喜好哦！ 小提示全部歌曲都可以直接点击播放 关于我喜欢的音乐风格小时候对于听歌这件事主要还是小时侯家庭的影响，在我还在母亲肚子里时我父母听到别人聊天时说到听音乐也是一种“胎教”，便两个人去了我们这个小城市的音响店买了一对立式的音响和一个功放机，开始在家里播放音乐，根据后来他们所说，最早期播放的大多是古典音乐，像莫扎特、巴赫的钢琴曲和交响曲，后来觉得有些乏味，便开始播放邓丽君，陈百强，张学友的歌曲。 var ap = new APlayer({ element: document.getElementById(\"aplayer-afzpqhIl\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"月亮代表我的心\", author: \"邓丽君\", url: \"https://music.163.com/song/media/outer/url?id=228755.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); var ap = new APlayer({ element: document.getElementById(\"aplayer-PBChFRvh\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"偏偏喜欢你\", author: \"陈百强\", url: \"https://music.163.com/song/media/outer/url?id=27874938.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); var ap = new APlayer({ element: document.getElementById(\"aplayer-ucbvKQDo\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"吻别\", author: \"张学友\", url: \"https://music.163.com/song/media/outer/url?id=190449.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 如今在我家书柜还存放着当年的CD，但也有一部分在搬家的过程中丢失了。我父母在我小时候的印象里总是会抱着一些CD回来，放进CD机等待播放，印象最深刻的是两件事，第一个便是在CD机放进CD机后并不能马上播放歌曲，因为功放机还需要一点点的“热身”，叫做热机，功放在第一次开机时会有很清脆的滴答声，而真正热身好则是在大约2分钟后有一声非常清脆的滴答声，这个时候便可以按下CD机上的播放键了。 var ap = new APlayer({ element: document.getElementById(\"aplayer-goNqItMq\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Blue Bossa\", author: \"Eddie Higgins\", url: \"https://music.163.com/song/media/outer/url?id=1307049.mp3\", pic: \"https://i.loli.net/2021/04/08/FufDKxeGiPJdXNU.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 第二件印象深刻的事情便是小学每次放学坐公交车回家，常常会在走进屋子前听到里面传来的乐器声或者唱歌的人声，闷闷的，而打开门走进去的一瞬间耳朵就会被音乐包裹，如同爱丽丝掉进树洞一般，而如果开门前没有听到，估计是我做错了什么，需要提前做好挨揍的准备。我的许多音乐的来源在智能手机出现之前都是来自于家里CD所播放的音乐，还有一部分来自于《猫和老鼠》中的交响乐（哈）。 var ap = new APlayer({ element: document.getElementById(\"aplayer-wLphwkrl\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Tom and Jerry\", author: \"Bradley\", url: \"https://music.163.com/song/media/outer/url?id=25962464.mp3\", pic: \"https://i.loli.net/2021/04/08/UwXvYIDgdoznLMi.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 前智能手机在智能手机之前其实还有一个小小的时代，我叫做前智能时代，印象最深的便是诺基亚的5230型号，有着如今智能手机基本的功能，但是操作起来并不是那么顺畅，屏幕是电容屏，需要用手指戳下去才能响应，也有了那个时候的特色就是触控笔。 但当时可以将音乐随身放在一个手机里已经让我非常震撼了，当时传输的方式主要是用线连接电脑后传输，或者用蓝牙传输，蓝牙在那个时候可谓称得上是真正的黑科技，在电脑上选择文件，选择蓝牙传输到手机，那时候音乐的文件，大多数是acc或者mp3的文件，256k的音质，蓝牙的传输速率那时大约200k左右，传一张专辑的歌曲还是需要一点点耐心的。 诺基亚5230陪伴了我小学期间每天放学从学校到家里的一小段路，那时候也是网络歌手充斥网络的时代，和现在不同，那时候的网络歌手并没有一个完整的团队，很多时候只有自己录制自己唱歌就发到网上去了，虽然质量比不上如今的，但是很多经典的歌曲还是留了下来。尤其是经典的网恋歌曲…. var ap = new APlayer({ element: document.getElementById(\"aplayer-WqUhcFGv\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"爱到花开\", author: \"戊道子\", url: \"https://music.163.com/song/media/outer/url?id=5244681.mp3\", pic: \"https://i.loli.net/2021/04/08/jMLB9rwEWPbCF48.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 我印象里在小学三四年级天天回家听的就是这首可谓是网恋元祖歌曲哈哈哈哈，以至于在很长一段时间内听到这首歌的前奏都有点起鸡皮疙瘩的感觉….. 智能手机时代在初一的时候我真正的迎来了我的第一台智能手机，那便是大名鼎鼎(以前)的台湾手机厂商HTC(火腿肠)的Incredible S，出厂预装的是安卓2.2. 第一个下载的软件除了QQ便是QQ音乐了，还记得第一次打开QQ音乐，主页上扑面而来的帅气男人，那肯定就是周董了 var ap = new APlayer({ element: document.getElementById(\"aplayer-vpOUuAmq\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"说好的幸福呢\", author: \"周杰伦\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/周杰伦-说好的幸福呢.mp3\", pic: \"https://i.loli.net/2021/04/08/aILZKwO18o92p3T.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); var ap = new APlayer({ element: document.getElementById(\"aplayer-wIAKCRGd\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"花海\", author: \"周杰伦\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/周杰伦-花海.mp3\", pic: \"https://i.loli.net/2021/04/08/aILZKwO18o92p3T.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); var ap = new APlayer({ element: document.getElementById(\"aplayer-gtdrbjtu\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"给我一首歌的时间\", author: \"周杰伦\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/周杰伦-给我一首歌的时间.mp3\", pic: \"https://i.loli.net/2021/04/08/aILZKwO18o92p3T.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 也是在听过周董的歌之后，我对于自己所喜欢的音乐才有了一个初步的理解，那时的我喜欢干净的音乐，在歌曲里各种乐器的位置摆放合理，不会互相打架，用尽可能少的乐器演绎出丰富的听觉效果，而在那个时候，听得最多的除了周董，便是李荣浩了。 第一次认识李荣浩是在电台里，在FM102.2深夜12点开始的节目叫做《千里共良宵》，某一次广告前的过场音乐直接抓住了我的耳朵，13年的听歌识曲并不完善，我只能尽可能的记住歌词，然后再去搜索，那时候我印象最深的一句便是“越勇敢越孤单”，这一句便让我认识了李荣浩。 var ap = new APlayer({ element: document.getElementById(\"aplayer-QtxjomGX\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"都一样\", author: \"李荣浩\", url: \"https://music.163.com/song/media/outer/url?id=27731172.mp3\", pic: \"https://i.loli.net/2021/04/08/X6V1nOjuELw3pSF.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 那段时间向身边的同学推荐李荣浩，他们的表情就像李荣浩的眼睛一样，眯成了一条缝，那个时候没有抖音，大家听歌还是有耐心听完一整首的，大家所喜欢的风格也不同，但李荣浩在那个时候可谓时流行音乐的一个异类，前有R&amp;B教父陶喆、周董还有陈奕迅三座大山，那时候很多人说李荣浩是周杰伦加陈奕迅，也有人说李荣浩的音乐千篇一律，但是李荣浩确实闯出了一条路来。 var ap = new APlayer({ element: document.getElementById(\"aplayer-NTOnlBWL\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"不搭\", author: \"李荣浩\", url: \"https://music.163.com/song/media/outer/url?id=29764563.mp3\", pic: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/img/14ce36d3d539b6009f46967be350352ac75cb776.jpeg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 李荣浩最厉害的对于和声的运用，这与他多年的幕后经验是紧密相关的，许多歌曲旋律并不复杂但和声的运用使得歌曲增彩不少。 吉他在初三中考完的假期内我拥有了我的第一把吉他，也就是这个时候我开始真正的不仅仅去听音乐，更想要去触碰音乐。 var ap = new APlayer({ element: document.getElementById(\"aplayer-oZCopOOW\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"拥抱\", author: \"五月天\", url: \"https://music.163.com/song/media/outer/url?id=386542.mp3\", pic: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/img/a8014c086e061d95bcc46a0c79f40ad162d9ca00.jpeg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 五月天的拥抱是我学习的第一首歌曲，当时是一位朋友的朋友在唱吧上唱了这一首并且分享给了我，当时第一次听到我便下定决心要学会这一首拥抱，第二天打开吉他教材，噢～好家伙，第一页就是这首歌的谱子，也就是在这样的机缘巧合下我慢慢开始学习一首又一首的歌，我也开始接触指弹。 var ap = new APlayer({ element: document.getElementById(\"aplayer-ULLvDege\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"LOVIN' YOU\", author: \"押尾コータロー\", url: \"https://music.163.com/song/media/outer/url?id=22822506.mp3\", pic: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/img/s4716396.jpeg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 押尾桑的许多歌曲都可谓是吉他指弹入门的必练曲，到并不是因为多简单，而是因为实在是太好听了，虽然许多人都认为押尾的歌曲的难度稍低，但是如果想要完整流畅地弹奏下来还是需要多年的苦练的。而上面这一首LOVIN’ YOU则是我第一首学会弹奏的指弹曲，直到现在我也不敢说我已经可以完全无压力地弹奏下来了，每一次弹奏都为这精致的编排所震撼。 在押尾桑后我开始了解更多来自世界各地的指弹大师，首先当然是来自澳洲的Tommy Emmanuel，还记得第一次听到close to you的弹奏时，我根本不相信这是一把吉他所能创造的效果，各种技巧和和弦都是为了旋律服务的感觉实在是太棒了。也让我对吉他的理解更加的深刻。 var ap = new APlayer({ element: document.getElementById(\"aplayer-zGOqjSVk\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Since We Met\", author: \"Tommy Emmanuel\", url: \"https://music.163.com/song/media/outer/url?id=2002030.mp3\", pic: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/img/s3681710.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 当然除了Tommy Emmanuel我还尤其喜欢来自日本的伍伍慧，他极具天赋的编曲以及各种古典技巧的融合使得他的曲子听起来尤其的活泼以及有生气，他所改编的爵士名曲Moon River不仅仅尤其地温暖，而且其中的改编更让人如痴如醉。 var ap = new APlayer({ element: document.getElementById(\"aplayer-BsMwaOnG\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Moon River\", author: \"伍伍慧\", url: \"https://music.163.com/song/media/outer/url?id=26450089.mp3\", pic: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/img/s27996751.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 方大同终于在高中，我开始认识方大同。 var ap = new APlayer({ element: document.getElementById(\"aplayer-tDZvIQnd\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"红豆\", author: \"方大同\", url: \"https://m10.music.126.net/20210517202811/6dd994d699da3e242260e335e3880d91/ymusic/ff10/edf4/18cd/a81822d7d51e1de5206569eb09576e58.mp3\", pic: \"https://s2.loli.net/2023/05/17/o4O1ueAUaZcvn56.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); “有时候 有时候 我会相信一切有尽头 相聚离开都有时候 没有什么会永垂不朽 可是我 有时候 宁愿选择留恋不放手 等到风景都看透 也许你会陪我看细水长流 ” 那天晚上是我第一次认真听方大同的歌，回到宿舍我马上去向朋友借了一把吉他，开始弹奏方大同的红豆。也是第一次我从心底感觉原来弹唱也可以这么酷，吉他的编排可以如此抓耳朵。我一直弹一直弹，我舍友久违地说了一句：真好听啊。在那个时候我知道方大同这个男人以后应该会陪我很久很久了。 第二天在秋游的路上我也一直在耳机里不断地循环，回来的路上也是。 第二天开始我开始听方大同的其他歌曲，刚开始这并不是一个很顺畅的过程，以往的流行歌曲经验对于大同的歌曲来说并不管用，无论是旋律，和声，和弦，对于我来说都完全是崭新的，我还记得第一次听《暖》，并不觉得这首歌是我的菜，直到两天后第二次听，才发现，噢！太棒了！ var ap = new APlayer({ element: document.getElementById(\"aplayer-SNVDRWOW\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"暖\", author: \"方大同\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/方大同-暖.mp3\", pic: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/img/9825bc315c6034a82b7f9283c313495409237616.jpeg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 大同的许多歌曲都是如此，有着难以言喻的前瞻性，让你在每一次重播时都觉得，这首歌太潮了！ 也是因为大同，我对于音乐的理解更加深入，大同的许多音乐灵感其实是来自于他小时候所听的黑人音乐，爵士乐，放克，还有各种灵魂乐，布鲁斯以及R&amp;B。也使得他的歌曲不仅仅多元，而且极具创造性，各种即兴信手拈来。 也是在那个时候开始我开始收集方大同的专辑，像让大同的声音在音响上呈现，我第一张真正意义上的方大同发行专辑便是《橙月》。 var ap = new APlayer({ element: document.getElementById(\"aplayer-EprBlfnw\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"小小虫\", author: \"方大同\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/方大同-小小虫.mp3\", pic: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/img/9d82d158ccbf6c81d15b405dbc3eb13533fa4012.jpeg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 随着听大同的歌曲越来越来，我发现我的耳朵也变刁了，尤其是听到流行歌曲的时候，不自主地会与大同的歌曲进行比较，如果这首歌是完完全全在套路之内的，那我大可能就把这首歌给pass掉，但如果有意料之外的旋律或者和弦就会马上吸引到我。 疫情疫情期间我开始花大量的时间去听歌，一天的时间都泡在音乐App中，巧合的是，在某一个晚上我打开YouTube，首页给我推荐了一张合辑，名字叫做睡前R&amp;B，封面是昏暗的房间，地上摆放着各种唱片，点击，便让我发现了这一位宝藏歌手。 var ap = new APlayer({ element: document.getElementById(\"aplayer-kQLbcYnU\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"easy\", author: \"Mac Ayres\", url: \"https://music.163.com/song/media/outer/url?id=519943092.mp3\", pic: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/img/s29520620.jpeg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 许多人评价Mac Ayres是如今被远远低估的R&amp;B歌手，我也很赞同，但他才23岁，未来可期。 这首歌还在被我用在了歌手大赛的复赛中（由于英语发音根本不标准被评委吐槽，但如果叫我评选2020年我的年度单曲，我会毫不犹豫地选择这首歌） 在疫情中我还认识了另外一位“老师”，那便是来自台湾的“李友廷老师”了 李友廷以极强的吉他演奏能力和极具个人风格的作品在台湾的综艺节目声林之王第一季夺得冠军，并在2020年底终于推出了首张个人专辑《如果你也爱我就好了》，听就好了。 var ap = new APlayer({ element: document.getElementById(\"aplayer-KcFyKjng\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"直到我遇见了你\", author: \"李友廷\", url: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/musicstore/李友廷-直到我遇见了你.mp3\", pic: \"https://cdn.jsdelivr.net/gh/hamster1963/photostore/img/s33763909.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 本月推荐歌单 @ @@ @@@ @@@@ @@@@@ @@@@@@ @@@@@@@ @@@@@@@@ @@@@@@@@@ 彩蛋谢谢你的阅读 致敬那些漫漫长夜 谢谢ni。 2021.4.11","categories":[{"name":"音乐分享","slug":"音乐分享","permalink":"https://buycoffee.top/categories/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"https://buycoffee.top/tags/%E9%9F%B3%E4%B9%90/"}],"author":"Hamster"},{"title":"今日校园自动填写表单信息脚本","slug":"今日校园自动填写辅导员信息脚本","date":"2021-05-17T16:00:00.000Z","updated":"2023-05-17T00:55:03.000Z","comments":true,"path":"2021/05/18/今日校园自动填写辅导员信息脚本/","link":"","permalink":"https://buycoffee.top/2021/05/18/%E4%BB%8A%E6%97%A5%E6%A0%A1%E5%9B%AD%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99%E8%BE%85%E5%AF%BC%E5%91%98%E4%BF%A1%E6%81%AF%E8%84%9A%E6%9C%AC/","excerpt":"","text":"致谢感谢Finch、柠火提供的方法与思路。 使用方法Windows在windows系统下，下载压缩包，在文件夹内部按住shift并单击右键，选择 在命令行中输入 python3 DailyCP.py 学校全名 学号 密码 定位地址 formdb文件夹绝对路径 例如 python3 DailyCP.py xx大学 3****9 d***4 广*******路 &#x2F;Users&#x2F;*****&#x2F;Desktop&#x2F;Campus-master&#x2F;formdb 输入后回车即可。 macOS在mac系统下首先打开终端，使用cd定位到DailyAUTO文件夹。 在命令行中输入 python3 DailyCP.py 学校全名 学号 密码 定位地址 formdb文件夹绝对路径 例如 python3 DailyCP.py xx大学 3****9 d***4 广*******路 &#x2F;Users&#x2F;*****&#x2F;Desktop&#x2F;Campus-master&#x2F;formdb 输入后回车即可。 第一次使用在第一次使用的时候会在屏幕上打印提醒 请手动填写&#x2F;Users&#x2F;***&#x2F;Desktop&#x2F;DailyAUTO&#x2F;formdb&#x2F;910e5efaed9eaea5f146faa60c3ab47a.json，之后重新运行脚本 在formdb文件夹中找到相对应的json文件，使用文本编辑器打开（推荐vscode），如果打开后发现数据都集中在一行，请单击右键单击 填写规范请查看1129.json文件。 主要修改的为select项，如果对应的为选中，则将其修改为 &quot;isSelected&quot;: 1 反之则为 &quot;isSelected&quot;: null 注意是单选还是多选题，切勿在单选题中修改多项select值为1。 正式运行再次在命令行中输入上述命令 等待程序运行，在正常情况下会首先打印学校名字及登录地址，并打印所需要填写的表单的基本信息，下一行会打印表单详细信息（你已经填写好的）。 ​ 数据已经脱敏 如果是今天的第一次填写，将会返还”SUCCESS” 如果已经填写，将会返还”该收集已填写无需再次填写” 警告此程序仅供学习，请勿用于违法途径。 文件下载地址由于法律与政策，下载地址不予显示。","categories":[{"name":"python开发","slug":"python开发","permalink":"https://buycoffee.top/categories/python%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"python，网络","slug":"python，网络","permalink":"https://buycoffee.top/tags/python%EF%BC%8C%E7%BD%91%E7%BB%9C/"}],"author":"Hamster"},{"title":"在搭载M1芯片的mac上使用face_recognition库实现实时人脸识别小demo","slug":"M1 人脸识别","date":"2021-05-15T16:00:00.000Z","updated":"2023-05-17T01:23:48.570Z","comments":true,"path":"2021/05/16/M1 人脸识别/","link":"","permalink":"https://buycoffee.top/2021/05/16/M1%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/","excerpt":"","text":"前言​ 在搭载M1芯片的mac上顺利进行开发是一件不仅随缘而且需要人品的事情，不仅仅因为M1芯片的ARM架构所带来的编译方式的不同，bugsur新的文件路径系统以及时不时的抽风也使得顺利开发的路上艰难险阻。今天就来看看GitHub上大名鼎鼎的开源人脸库face_recognition如何比较顺利地在M1上跑起来且实现简单的实时人脸识别的功能。 由于不可描述的原因，网络环境所造成的安装失败不在本文讨论范围中。 第一部分 关于环境的那点事网络环境搭建建议进行设置省去不必要的麻烦 大部分的环境搭建与库安装需要使用终端进行，由于终端默认并不走代理的网络， 为了此后下载的顺利，先需要设置终端也可以使用代理。 首先，在当前用户根目录新建一个文件名为 .bash_profile的空白文本「. 开头文件为隐藏文件」，然后输入以下代码： .bash_profilefunction proxy_off()&#123; unset http_proxy unset https_proxy unset ftp_proxy unset rsync_proxy echo -e &quot;已关闭代理&quot;&#125; function proxy_on() &#123; export no_proxy=&quot;localhost,127.0.0.1,localaddress,.localdomain.com&quot; export http_proxy=&quot;https://127.0.0.1:1087&quot; export https_proxy=$http_proxy export ftp_proxy=$http_proxy export rsync_proxy=$http_proxy export HTTP_PROXY=$http_proxy export HTTPS_PROXY=$http_proxy export FTP_PROXY=$http_proxy export RSYNC_PROXY=$http_proxy echo -e &quot;已开启代理&quot;&#125; 在export no_proxy与export http_proxy填入对应的本地代理服务器地址以及端口 可以在你的代理软件中查看 将文件配置好并放在用户根目录后 当让终端走代理的时候，输入：source ~&#x2F;.bash_profileproxy_on 想关闭代理的时候，输入：proxy_off 此为一次性设置，关闭终端后失效 基本环境搭建安装python最新版本从python官网下载最新版本python 记得选中 macOS 64-bit universal2 installer 下载地址https://www.python.org/downloads/mac-osx/ 安装完成后在终端输入 open ~&#x2F;.bash_profile 在文件中加上一行环境变量配置后保存退出 export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:$PATH 重新打开终端输入 source ~&#x2F;.bash_profile python3 --version -------注意是python3 顺利的话你会在终端中看到python的版本号信息，python安装到此结束 各种依赖包安装radiationyellow, 头铁的可以试试直接安装 设置好终端网络代理后 在终端中输入 pip3 install face_recognition 在安装face_recognition之前我们需要安装 homebrew miniforge numpy openblas opencv cmake dlib 安装homebrew唯一的重点是配置环境变量 下载安装过程略 安装完成后根据提示在终端中输入 open ~&#x2F; .zprofile 在文件中加入 eval &quot;$(&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew shellenv)&quot; 保存后重启homebrew，在终端中输入 brew 如果出现各种指令提示，证明安装成功 安装miniforge注意鉴于M1版本的开发工具适配进程目前并不同步，所以这里使用miniforge来进行库管理 在网站中选择Apple Silicon版本下载，下载后直接运行即可 接下来我们需要在终端中激活 conda create -n myenv python&#x3D;3.9 &#x2F;&#x2F;创建名为myenv，python版本为3.9的环境conda activate myenv &#x2F;&#x2F;激活环境 安装numpy激活conda且配置好网络代理后可以直接在终端中输入 pip3 install numpy&#x3D;1.9.14 等待下载安装，安装完成后检测是否安装成功，在终端中输入 python3&gt;&gt;&gt;import numpy 没报错的话就安装成功了 安装openblas激活conda且配置好网络代理后可以直接在终端中输入 pip3 install openblas 等待下载安装，安装完成后检测是否安装成功，在终端中输入 python3 &gt;&gt;&gt;import openblas 没报错安装成功 需要编译的库opencv cmake dlib 这三个包如果安装失败，可以多试几次，cmake有概率编译失败 安装opencv点击链接下载opencv库，仅适用于M1芯片 opencv_contrib_python-4.5.0+bbaa777-cp39-cp39-macosx_11_0_arm64.whl 在终端中激活环境 conda activate myenv &#x2F;&#x2F;激活环境 定位到下载目录并安装 cd 目录pip3 install opencv_contrib_python-4.5.0+bbaa777-cp39-cp39-macosx_11_0_arm64.whl 等待安装即可 安装cmake终端配置好网络代理后输入 brew install cmake &#x2F;&#x2F;安装cmake 安装Dlib激活conda且配置好网络代理后直接在终端中输入 pip3 install dlib 安装后在终端输入 python3&gt;&gt;&gt;import dlib 如果未报错恭喜你安装成功，我们就差最后一步了 对着检查一下吧 homebrew miniforge numpy openblas opencv cmake dlib 安装face_recognition激活conda且配置好网络代理后直接在终端中输入 pip3 install face_recognition 如果出现了任何错误，欢迎在评论区告诉我 温馨提示此过程需要网络以及人品双buff叠加，请坐和放宽…… 安装完成后在终端中输入 python3&gt;&gt;&gt;import face_recognition 如果没有报错证明万里长征我们已经走了一半了。 也可以使用 pip3 list 命令来查看所有已经安装的库 如图 到此安装告一段落 第二部分 开始造轮子吧由于安装这些依赖和库可能已经损耗你的大部分精力了， 所以接下来我们就快速地来看看怎么把这个简单的实时人脸识别跑起来吧。 摄像头是必须的，所以请不要关上盖子运行接下来的步骤 下载py文件从GitHub上下载 facerec_from_webcam_faster.py 使用编辑器编辑用你喜欢的编辑器打开，这里使用vscode示范，下面代码都是从源文件中截出，对应修改即可。 # Load a sample picture and learn how to recognize it.图片人名1_image = face_recognition.load_image_file(&quot;把这里改成你要识别的图片的路径&quot;) 图片人名1_face_encoding = face_recognition.face_encodings(图片人名1_image)[0]# Load a second sample picture and learn how to recognize it.图片人名2_image = face_recognition.load_image_file(&quot;把这里改成你要识别的图片2的路径&quot;)图片人名2_face_encoding = face_recognition.face_encodings(图片人名1_image)[0]# Create arrays of known face encodings and their namesknown_face_encodings = [ 图片人名1_face_encoding, 图片人名2_face_encoding]known_face_names = [ &quot;图片1所对应的全名&quot;, &quot;图片2所对应的全名&quot;] 例子如图，图片1为Obama，图片2为biden 运行一下吧！打开终端，输入 python3 &lt;将文件拖到这里或者粘贴文件的路径&gt; 就像这样 按下回车等待奇迹的发生 不出意外的话，掏出你的小手机拿出一张照片或者把你的脸对准摄像头，就可以看到 大功告成啦！尾巴总体来说跑起这个小项目还是基本没有难度的，最主要的是有稳定的网络以及足够的耐心 face_recognition这个库具有很多方向的应用，今天只是简单地入门一下，还有很多玩法可以发掘哦！ 致谢谢谢阅读，欢迎你的留言！","categories":[{"name":"python开发","slug":"python开发","permalink":"https://buycoffee.top/categories/python%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"python","slug":"python","permalink":"https://buycoffee.top/tags/python/"},{"name":"macOS","slug":"macOS","permalink":"https://buycoffee.top/tags/macOS/"},{"name":"M1","slug":"M1","permalink":"https://buycoffee.top/tags/M1/"},{"name":"face_recognition","slug":"face-recognition","permalink":"https://buycoffee.top/tags/face-recognition/"},{"name":"人脸识别","slug":"人脸识别","permalink":"https://buycoffee.top/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"}],"author":"Hamster"},{"title":"在openwrt上使用DDNSTO插件进行远程管理","slug":"DDNSTO","date":"2021-04-04T16:00:00.000Z","updated":"2023-05-17T01:18:12.000Z","comments":true,"path":"2021/04/05/DDNSTO/","link":"","permalink":"https://buycoffee.top/2021/04/05/DDNSTO/","excerpt":"","text":"DDNSTO有付费与免费两种模式选择，免费套餐需要每隔7天手动进行一次续期 前言openwrt是目前众多路由器刷机的选择，界面美观而且插件丰富，但是有一定的上手成本，远程管理路由器在openwrt上的配置并不简单，ddnsto的出现大大降低了新手的使用成本，使用体验也十分友好。 使用教程小提示本插件理论上适用于任何基于openwrt的原版或者第三方路由器 本文使用LEDE固件进行演示 安装DDNSTO插件从网站中下载对应架构版本的ipk文件 下载地址https://firmware.koolshare.cn/binary/ddnsto/openwrt/ 在openwrt路由器后台管理界面中安装插件 使用文件传输功能将.ipk文件上传至/tmp/upload/ 上传成功后跳转至软件包页面 在下载并安装软件包输入框中输入/tmp/upload/对应的名字.ipk等待安装完成 在服务中看到DDNS.to内网穿透一栏就证明安装成功了 配置DDNSTO打开https://www.ddnsto.com点击右上角登录后台并使用微信注册 复制页面上的令牌 回到路由器页面打开DDNS.to插件页面在令牌框内将复制的令牌粘贴并勾选启用，点击页面的保存&amp;应用 稍等片刻回到DDNSTO后台，你的路由器应该就会出现在页面中。 点击添加域名映射，输入你喜欢的名字并将路由器的内网地址填入并保存。 使用DDNSTO一切配置完成后应该如图一样 点击给出的域名，如果可以正确跳转至路由器管理页面，恭喜你已经可以正常使用啰！SEE YOU NEXT TIME！","categories":[{"name":"openwrt","slug":"openwrt","permalink":"https://buycoffee.top/categories/openwrt/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://buycoffee.top/tags/openwrt/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://buycoffee.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}],"author":"Hamster"},{"title":"利用python写一个自动获取局域网ip地址并开启SS服务器的小工具","slug":"校园网SS服务器","date":"2021-03-29T16:00:00.000Z","updated":"2023-05-17T01:00:18.849Z","comments":true,"path":"2021/03/30/校园网SS服务器/","link":"","permalink":"https://buycoffee.top/2021/03/30/%E6%A0%A1%E5%9B%AD%E7%BD%91SS%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"前言这个学年学校把宽带运营商从之前的联通大哥哥换成了如今的电信小弟弟，使用体验可谓一落千丈，最主要的原因是电信不再像联通提供拨号上网的账号和密码，改成了强制使用天翼校园的程序来进行认证上网，而且限制只能一台设备在线，这直接搞垮了宿舍内的一堆需要联网的设备，首先想到的是通过电脑先连接在共享给路由器，感谢这位兄弟提供的方法@task138，但是转念一想，既然学校内覆盖了校园网，那是否可以使用电脑搭建服务器从而达到在校园网范围内手机或者iPad都可以上网呢?这就是今天讨论的方法。 此方法仅限交流，请勿在保密场所使用 目前仅适用于Windows 源码:https://github.com/hamster1963/-SS- 实现效果自动获取本机局域网地址并写入配置文件 自动获取本机局域网地址并写入配置文件 开启时显示各项配置参数，帮助使用者配置代理软件 开启SS代理服务器，出错时显示错误弹窗 原理与改进开启SS代理服务器部分参考了GitHub上的shadowsocks-libqss项目，需要使用者手动填写config文件，使用起来学习成本有一点高，且如果没有成功运行也没有错误提示，所以使用python编写一个小脚本改进一下，以达到上述的功能。 使用方法windows开启服务器想开启SS代理服务器十分简单，如果不想更改默认的端口、密码、加密方式，可以直接双击使用 开启SS代理服务器.exe，打开后根据弹窗配置自己的代理软件，安卓小飞机，苹果小火箭，windows使用clash，macOS使用surge。 一切顺利后应该是这样的界面 ios使用小火箭连接在小火箭中点击右上角加号，类型选择Shadowsocks，根据配置弹窗中的信息，填入相关配置，混淆与插件为空。如图: macos使用surge连接打开surge面板，在策略中选择添加 填入配置信息，出站选择全局代理即可 surge教程到此结束 程序编写我们的目标其实很简单，就是获取当前IP地址并且写入到config文件中，并在启动服务器时有弹窗包含主要配置信息提醒用户。 获取ip地址这是一个很通用的获取本机局域网ip地址的方法，代码如下: #获取实时IP地址def get_host_ip(): &quot;&quot;&quot; 查询本机ip地址 :return: ip &quot;&quot;&quot; try: s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((&#x27;8.8.8.8&#x27;, 80)) ip = s.getsockname()[0] finally: s.close() return ip 将ip地址写入配置文件配置文件的类型是json，在python中我们可以很轻松地修改json文件内的值，只需要知道key和value的对应关系即可，代码如下: #将IP地址写入json文件filename = &#x27;config.json&#x27;with open(filename, &#x27;r&#x27;) as f: data = json.load(f) data[&#x27;server&#x27;] = get_host_ip() # &lt;--- 添加实时ip地址.os.remove(filename)with open(filename, &#x27;w&#x27;) as f: json.dump(data, f, indent=4) 由于上面的 get_host_ip()是直接返还ip地址的，所以在server的value部分我们直接使用get_host_ip()即可。 读取基础配置信息在开屏弹窗中我们需要显示基本信息，所以我们先需要读取json文件内的我们需要的value值，代码如下: #读取json 获取端口/密码/加密方式filename = &#x27;config.json&#x27;with open(filename, &#x27;r&#x27;) as f: data = json.load(f) a = data[&#x27;password&#x27;] b = data[&#x27;server_port&#x27;] c = data[&#x27;method&#x27;] 弹窗弹窗使用的是tkinter库，语法也十分简单，代码如下: def talk(): tkinter.messagebox.showinfo(&quot;提示&quot;,&quot;你的ip地址是&quot; + get_host_ip()+&quot;\\n你的端口号是&quot;+str(b)+&quot;\\n你的密码是&quot; + a + &quot;\\n加密方式是&quot;+ c +&quot;\\n请勿关闭cmd窗口&quot;) 实现界面如图 主程序基本的小组件都写好了我们最后就把积木拼成小车车🚗就可以了,加入检测是否运行成功的弹窗，代码如下: #主程序netopen = threading.Thread(target=runserver)#, daemon=True)if __name__==&#x27;__main__&#x27;: netopen.start() if netopen.is_alive() == True: #弹窗显示 talk() tkinter.messagebox.showinfo(&quot;欢迎&quot;,&quot;开启成功,如需退出请关闭cmd窗口&quot;) if netopen.is_alive() == False: tkinter.messagebox.showinfo(&quot;退出&quot;,&quot;服务已退出，请检查配置&quot;) quote,由于我们是调用了外部的程序，所以这里使用线程监控来实现检测服务器程序是否正确运行。 大功告成完整源码如下 import jsonimport osimport socketimport tkinterimport tkinter.messageboxfrom threading import Threadimport threading#初始化弹窗root = tkinter.Tk()root.withdraw()root.wm_attributes(&#x27;-topmost&#x27;,1)#获取实时IP地址def get_host_ip(): &quot;&quot;&quot; 查询本机ip地址 :return: ip &quot;&quot;&quot; try: s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((&#x27;8.8.8.8&#x27;, 80)) ip = s.getsockname()[0] finally: s.close() return ip#将IP地址写入json文件filename = &#x27;config.json&#x27;with open(filename, &#x27;r&#x27;) as f: data = json.load(f) data[&#x27;server&#x27;] = get_host_ip() # &lt;--- 添加实时ip地址.os.remove(filename)with open(filename, &#x27;w&#x27;) as f: json.dump(data, f, indent=4)#读取json 获取端口/密码/加密方式filename = &#x27;config.json&#x27;with open(filename, &#x27;r&#x27;) as f: data = json.load(f) a = data[&#x27;password&#x27;] b = data[&#x27;server_port&#x27;] c = data[&#x27;method&#x27;]def runserver(): os.system(&#x27;shadowsocks-server.bat&#x27;)def talk(): tkinter.messagebox.showinfo(&quot;提示&quot;,&quot;你的ip地址是&quot; + get_host_ip()+&quot;\\n你的端口号是&quot;+str(b)+&quot;\\n你的密码是&quot; + a + &quot;\\n加密方式是&quot;+ c +&quot;\\n请勿关闭cmd窗口&quot;) #主程序netopen = threading.Thread(target=runserver)#, daemon=True)if __name__==&#x27;__main__&#x27;: netopen.start() if netopen.is_alive() == True: #弹窗显示 talk() tkinter.messagebox.showinfo(&quot;欢迎&quot;,&quot;开启成功,如需退出请关闭cmd窗口&quot;) if netopen.is_alive() == False: tkinter.messagebox.showinfo(&quot;退出&quot;,&quot;服务已退出，请检查配置&quot;) 逻辑还是比较简单的，基本就是在调用不同的组件，但是成品还是很不错的，大大降低了学习和使用成本。 最后想说的话这个方法对于校园网来说只能算是另辟蹊径，并没有完全从根本上解决问题，如果天翼校园的客户端能写得好一点，连接设备数能放宽一点，想必会受到更多学生的接纳。See you next time！欢迎评论！","categories":[{"name":"python开发","slug":"python开发","permalink":"https://buycoffee.top/categories/python%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"python","slug":"python","permalink":"https://buycoffee.top/tags/python/"},{"name":"网络","slug":"网络","permalink":"https://buycoffee.top/tags/%E7%BD%91%E7%BB%9C/"},{"name":"服务器","slug":"服务器","permalink":"https://buycoffee.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"SS","slug":"SS","permalink":"https://buycoffee.top/tags/SS/"},{"name":"校园网","slug":"校园网","permalink":"https://buycoffee.top/tags/%E6%A0%A1%E5%9B%AD%E7%BD%91/"}],"author":"Hamster"}],"categories":[{"name":"GitHub","slug":"GitHub","permalink":"https://buycoffee.top/categories/GitHub/"},{"name":"Docker","slug":"Docker","permalink":"https://buycoffee.top/categories/Docker/"},{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/categories/Go/"},{"name":"Docker","slug":"Go/Docker","permalink":"https://buycoffee.top/categories/Go/Docker/"},{"name":"Github","slug":"Go/Docker/Github","permalink":"https://buycoffee.top/categories/Go/Docker/Github/"},{"name":"科学上网","slug":"科学上网","permalink":"https://buycoffee.top/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"音乐分享","slug":"音乐分享","permalink":"https://buycoffee.top/categories/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"},{"name":"python开发","slug":"python开发","permalink":"https://buycoffee.top/categories/python%E5%BC%80%E5%8F%91/"},{"name":"openwrt","slug":"openwrt","permalink":"https://buycoffee.top/categories/openwrt/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://buycoffee.top/tags/GitHub/"},{"name":"Docker","slug":"Docker","permalink":"https://buycoffee.top/tags/Docker/"},{"name":"Go","slug":"Go","permalink":"https://buycoffee.top/tags/Go/"},{"name":"Network","slug":"Network","permalink":"https://buycoffee.top/tags/Network/"},{"name":"Github","slug":"Github","permalink":"https://buycoffee.top/tags/Github/"},{"name":"Router","slug":"Router","permalink":"https://buycoffee.top/tags/Router/"},{"name":"网络","slug":"网络","permalink":"https://buycoffee.top/tags/%E7%BD%91%E7%BB%9C/"},{"name":"音乐","slug":"音乐","permalink":"https://buycoffee.top/tags/%E9%9F%B3%E4%B9%90/"},{"name":"python，网络","slug":"python，网络","permalink":"https://buycoffee.top/tags/python%EF%BC%8C%E7%BD%91%E7%BB%9C/"},{"name":"python","slug":"python","permalink":"https://buycoffee.top/tags/python/"},{"name":"macOS","slug":"macOS","permalink":"https://buycoffee.top/tags/macOS/"},{"name":"M1","slug":"M1","permalink":"https://buycoffee.top/tags/M1/"},{"name":"face_recognition","slug":"face-recognition","permalink":"https://buycoffee.top/tags/face-recognition/"},{"name":"人脸识别","slug":"人脸识别","permalink":"https://buycoffee.top/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"},{"name":"openwrt","slug":"openwrt","permalink":"https://buycoffee.top/tags/openwrt/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://buycoffee.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"服务器","slug":"服务器","permalink":"https://buycoffee.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"SS","slug":"SS","permalink":"https://buycoffee.top/tags/SS/"},{"name":"校园网","slug":"校园网","permalink":"https://buycoffee.top/tags/%E6%A0%A1%E5%9B%AD%E7%BD%91/"}]}